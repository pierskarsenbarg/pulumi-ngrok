# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'EndpointConfigurationBackend',
    'EndpointConfigurationBackendBackend',
    'EndpointConfigurationBasicAuth',
    'EndpointConfigurationCircuitBreaker',
    'EndpointConfigurationCompression',
    'EndpointConfigurationIpPolicy',
    'EndpointConfigurationIpPolicyIpPolicy',
    'EndpointConfigurationLogging',
    'EndpointConfigurationLoggingEventStream',
    'EndpointConfigurationMutualTl',
    'EndpointConfigurationMutualTlCertificateAuthority',
    'EndpointConfigurationOauth',
    'EndpointConfigurationOauthProvider',
    'EndpointConfigurationOauthProviderFacebook',
    'EndpointConfigurationOauthProviderGithub',
    'EndpointConfigurationOauthProviderGoogle',
    'EndpointConfigurationOauthProviderMicrosoft',
    'EndpointConfigurationOidc',
    'EndpointConfigurationRequestHeader',
    'EndpointConfigurationResponseHeader',
    'EndpointConfigurationSaml',
    'EndpointConfigurationTlsTermination',
    'EndpointConfigurationWebhookValidation',
    'EventDestinationTarget',
    'EventDestinationTargetCloudwatchLog',
    'EventDestinationTargetCloudwatchLogAuth',
    'EventDestinationTargetCloudwatchLogAuthCred',
    'EventDestinationTargetCloudwatchLogAuthRole',
    'EventDestinationTargetDebug',
    'EventDestinationTargetFirehose',
    'EventDestinationTargetFirehoseAuth',
    'EventDestinationTargetFirehoseAuthCred',
    'EventDestinationTargetFirehoseAuthRole',
    'EventDestinationTargetKinese',
    'EventDestinationTargetKineseAuth',
    'EventDestinationTargetKineseAuthCred',
    'EventDestinationTargetKineseAuthRole',
    'EventSubscriptionSource',
    'ReservedDomainCertificateManagementPolicy',
    'TlsCertificateSubjectAlternativeName',
]

@pulumi.output_type
class EndpointConfigurationBackend(dict):
    def __init__(__self__, *,
                 backends: Optional[Sequence['outputs.EndpointConfigurationBackendBackend']] = None,
                 enabled: Optional[bool] = None):
        """
        :param Sequence['EndpointConfigurationBackendBackendArgs'] backends: backend to be used to back this endpoint
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        if backends is not None:
            pulumi.set(__self__, "backends", backends)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def backends(self) -> Optional[Sequence['outputs.EndpointConfigurationBackendBackend']]:
        """
        backend to be used to back this endpoint
        """
        return pulumi.get(self, "backends")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class EndpointConfigurationBackendBackend(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str id: a resource identifier
        :param str uri: a uri for locating a resource
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        a resource identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        a uri for locating a resource
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class EndpointConfigurationBasicAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowOptions":
            suggest = "allow_options"
        elif key == "authProviderId":
            suggest = "auth_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationBasicAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationBasicAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationBasicAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_options: Optional[bool] = None,
                 auth_provider_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 realm: Optional[str] = None):
        """
        :param bool allow_options: true or false indicating whether to allow OPTIONS requests through without authentication which is necessary for CORS. default is `false`
        :param str auth_provider_id: determines how the basic auth credentials are validated. Currently only the value `agent` is supported which means that credentials will be validated against the username and password specified by the ngrok agent's `--basic-auth` flag, if any.
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param str realm: an arbitrary string to be specified in as the 'realm' value in the `WWW-Authenticate` header. default is `ngrok`
        """
        if allow_options is not None:
            pulumi.set(__self__, "allow_options", allow_options)
        if auth_provider_id is not None:
            pulumi.set(__self__, "auth_provider_id", auth_provider_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)

    @property
    @pulumi.getter(name="allowOptions")
    def allow_options(self) -> Optional[bool]:
        """
        true or false indicating whether to allow OPTIONS requests through without authentication which is necessary for CORS. default is `false`
        """
        return pulumi.get(self, "allow_options")

    @property
    @pulumi.getter(name="authProviderId")
    def auth_provider_id(self) -> Optional[str]:
        """
        determines how the basic auth credentials are validated. Currently only the value `agent` is supported which means that credentials will be validated against the username and password specified by the ngrok agent's `--basic-auth` flag, if any.
        """
        return pulumi.get(self, "auth_provider_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def realm(self) -> Optional[str]:
        """
        an arbitrary string to be specified in as the 'realm' value in the `WWW-Authenticate` header. default is `ngrok`
        """
        return pulumi.get(self, "realm")


@pulumi.output_type
class EndpointConfigurationCircuitBreaker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorThresholdPercentage":
            suggest = "error_threshold_percentage"
        elif key == "numBuckets":
            suggest = "num_buckets"
        elif key == "rollingWindow":
            suggest = "rolling_window"
        elif key == "trippedDuration":
            suggest = "tripped_duration"
        elif key == "volumeThreshold":
            suggest = "volume_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationCircuitBreaker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationCircuitBreaker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationCircuitBreaker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 error_threshold_percentage: Optional[float] = None,
                 num_buckets: Optional[int] = None,
                 rolling_window: Optional[int] = None,
                 tripped_duration: Optional[int] = None,
                 volume_threshold: Optional[int] = None):
        """
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param float error_threshold_percentage: Error threshold percentage should be between 0 - 1.0, not 0-100.0
        :param int num_buckets: Integer number of buckets into which metrics are retained. Max 128.
        :param int rolling_window: Integer number of seconds in the statistical rolling window that metrics are retained for.
        :param int tripped_duration: Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health
        :param int volume_threshold: Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if error_threshold_percentage is not None:
            pulumi.set(__self__, "error_threshold_percentage", error_threshold_percentage)
        if num_buckets is not None:
            pulumi.set(__self__, "num_buckets", num_buckets)
        if rolling_window is not None:
            pulumi.set(__self__, "rolling_window", rolling_window)
        if tripped_duration is not None:
            pulumi.set(__self__, "tripped_duration", tripped_duration)
        if volume_threshold is not None:
            pulumi.set(__self__, "volume_threshold", volume_threshold)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="errorThresholdPercentage")
    def error_threshold_percentage(self) -> Optional[float]:
        """
        Error threshold percentage should be between 0 - 1.0, not 0-100.0
        """
        return pulumi.get(self, "error_threshold_percentage")

    @property
    @pulumi.getter(name="numBuckets")
    def num_buckets(self) -> Optional[int]:
        """
        Integer number of buckets into which metrics are retained. Max 128.
        """
        return pulumi.get(self, "num_buckets")

    @property
    @pulumi.getter(name="rollingWindow")
    def rolling_window(self) -> Optional[int]:
        """
        Integer number of seconds in the statistical rolling window that metrics are retained for.
        """
        return pulumi.get(self, "rolling_window")

    @property
    @pulumi.getter(name="trippedDuration")
    def tripped_duration(self) -> Optional[int]:
        """
        Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health
        """
        return pulumi.get(self, "tripped_duration")

    @property
    @pulumi.getter(name="volumeThreshold")
    def volume_threshold(self) -> Optional[int]:
        """
        Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.
        """
        return pulumi.get(self, "volume_threshold")


@pulumi.output_type
class EndpointConfigurationCompression(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class EndpointConfigurationIpPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipPolicies":
            suggest = "ip_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationIpPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationIpPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationIpPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 ip_policies: Optional[Sequence['outputs.EndpointConfigurationIpPolicyIpPolicy']] = None):
        """
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ip_policies is not None:
            pulumi.set(__self__, "ip_policies", ip_policies)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="ipPolicies")
    def ip_policies(self) -> Optional[Sequence['outputs.EndpointConfigurationIpPolicyIpPolicy']]:
        return pulumi.get(self, "ip_policies")


@pulumi.output_type
class EndpointConfigurationIpPolicyIpPolicy(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str id: a resource identifier
        :param str uri: a uri for locating a resource
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        a resource identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        a uri for locating a resource
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class EndpointConfigurationLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventStreams":
            suggest = "event_streams"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 event_streams: Optional[Sequence['outputs.EndpointConfigurationLoggingEventStream']] = None):
        """
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param Sequence['EndpointConfigurationLoggingEventStreamArgs'] event_streams: list of all EventStreams that will be used to configure and export this endpoint's logs
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if event_streams is not None:
            pulumi.set(__self__, "event_streams", event_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="eventStreams")
    def event_streams(self) -> Optional[Sequence['outputs.EndpointConfigurationLoggingEventStream']]:
        """
        list of all EventStreams that will be used to configure and export this endpoint's logs
        """
        return pulumi.get(self, "event_streams")


@pulumi.output_type
class EndpointConfigurationLoggingEventStream(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str id: a resource identifier
        :param str uri: a uri for locating a resource
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        a resource identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        a uri for locating a resource
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class EndpointConfigurationMutualTl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthorities":
            suggest = "certificate_authorities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationMutualTl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationMutualTl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationMutualTl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authorities: Optional[Sequence['outputs.EndpointConfigurationMutualTlCertificateAuthority']] = None,
                 enabled: Optional[bool] = None):
        """
        :param Sequence['EndpointConfigurationMutualTlCertificateAuthorityArgs'] certificate_authorities: PEM-encoded CA certificates that will be used to validate. Multiple CAs may be provided by concatenating them together.
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        if certificate_authorities is not None:
            pulumi.set(__self__, "certificate_authorities", certificate_authorities)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="certificateAuthorities")
    def certificate_authorities(self) -> Optional[Sequence['outputs.EndpointConfigurationMutualTlCertificateAuthority']]:
        """
        PEM-encoded CA certificates that will be used to validate. Multiple CAs may be provided by concatenating them together.
        """
        return pulumi.get(self, "certificate_authorities")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class EndpointConfigurationMutualTlCertificateAuthority(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str id: a resource identifier
        :param str uri: a uri for locating a resource
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        a resource identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        a uri for locating a resource
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class EndpointConfigurationOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCheckInterval":
            suggest = "auth_check_interval"
        elif key == "cookiePrefix":
            suggest = "cookie_prefix"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "maximumDuration":
            suggest = "maximum_duration"
        elif key == "optionsPassthrough":
            suggest = "options_passthrough"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_check_interval: Optional[int] = None,
                 cookie_prefix: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 inactivity_timeout: Optional[int] = None,
                 maximum_duration: Optional[int] = None,
                 options_passthrough: Optional[bool] = None,
                 providers: Optional[Sequence['outputs.EndpointConfigurationOauthProvider']] = None):
        """
        :param int auth_check_interval: Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.
        :param str cookie_prefix: the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param int inactivity_timeout: Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.
        :param int maximum_duration: Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.
        :param bool options_passthrough: Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.
        :param Sequence['EndpointConfigurationOauthProviderArgs'] providers: an object which defines the identity provider to use for authentication and configuration for who may access the endpoint
        """
        if auth_check_interval is not None:
            pulumi.set(__self__, "auth_check_interval", auth_check_interval)
        if cookie_prefix is not None:
            pulumi.set(__self__, "cookie_prefix", cookie_prefix)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if maximum_duration is not None:
            pulumi.set(__self__, "maximum_duration", maximum_duration)
        if options_passthrough is not None:
            pulumi.set(__self__, "options_passthrough", options_passthrough)
        if providers is not None:
            pulumi.set(__self__, "providers", providers)

    @property
    @pulumi.getter(name="authCheckInterval")
    def auth_check_interval(self) -> Optional[int]:
        """
        Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.
        """
        return pulumi.get(self, "auth_check_interval")

    @property
    @pulumi.getter(name="cookiePrefix")
    def cookie_prefix(self) -> Optional[str]:
        """
        the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'
        """
        return pulumi.get(self, "cookie_prefix")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[int]:
        """
        Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.
        """
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter(name="maximumDuration")
    def maximum_duration(self) -> Optional[int]:
        """
        Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.
        """
        return pulumi.get(self, "maximum_duration")

    @property
    @pulumi.getter(name="optionsPassthrough")
    def options_passthrough(self) -> Optional[bool]:
        """
        Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.
        """
        return pulumi.get(self, "options_passthrough")

    @property
    @pulumi.getter
    def providers(self) -> Optional[Sequence['outputs.EndpointConfigurationOauthProvider']]:
        """
        an object which defines the identity provider to use for authentication and configuration for who may access the endpoint
        """
        return pulumi.get(self, "providers")


@pulumi.output_type
class EndpointConfigurationOauthProvider(dict):
    def __init__(__self__, *,
                 facebooks: Optional[Sequence['outputs.EndpointConfigurationOauthProviderFacebook']] = None,
                 githubs: Optional[Sequence['outputs.EndpointConfigurationOauthProviderGithub']] = None,
                 googles: Optional[Sequence['outputs.EndpointConfigurationOauthProviderGoogle']] = None,
                 microsofts: Optional[Sequence['outputs.EndpointConfigurationOauthProviderMicrosoft']] = None):
        """
        :param Sequence['EndpointConfigurationOauthProviderFacebookArgs'] facebooks: configuration for using facebook as the identity provider
        :param Sequence['EndpointConfigurationOauthProviderGithubArgs'] githubs: configuration for using github as the identity provider
        :param Sequence['EndpointConfigurationOauthProviderGoogleArgs'] googles: configuration for using google as the identity provider
        :param Sequence['EndpointConfigurationOauthProviderMicrosoftArgs'] microsofts: configuration for using microsoft as the identity provider
        """
        if facebooks is not None:
            pulumi.set(__self__, "facebooks", facebooks)
        if githubs is not None:
            pulumi.set(__self__, "githubs", githubs)
        if googles is not None:
            pulumi.set(__self__, "googles", googles)
        if microsofts is not None:
            pulumi.set(__self__, "microsofts", microsofts)

    @property
    @pulumi.getter
    def facebooks(self) -> Optional[Sequence['outputs.EndpointConfigurationOauthProviderFacebook']]:
        """
        configuration for using facebook as the identity provider
        """
        return pulumi.get(self, "facebooks")

    @property
    @pulumi.getter
    def githubs(self) -> Optional[Sequence['outputs.EndpointConfigurationOauthProviderGithub']]:
        """
        configuration for using github as the identity provider
        """
        return pulumi.get(self, "githubs")

    @property
    @pulumi.getter
    def googles(self) -> Optional[Sequence['outputs.EndpointConfigurationOauthProviderGoogle']]:
        """
        configuration for using google as the identity provider
        """
        return pulumi.get(self, "googles")

    @property
    @pulumi.getter
    def microsofts(self) -> Optional[Sequence['outputs.EndpointConfigurationOauthProviderMicrosoft']]:
        """
        configuration for using microsoft as the identity provider
        """
        return pulumi.get(self, "microsofts")


@pulumi.output_type
class EndpointConfigurationOauthProviderFacebook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "emailDomains":
            suggest = "email_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationOauthProviderFacebook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationOauthProviderFacebook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationOauthProviderFacebook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 email_addresses: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.
        :param str client_secret: the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.
        :param Sequence[str] email_addresses: a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint
        :param Sequence[str] email_domains: a list of email domains of users authenticated by identity provider who are allowed access to the endpoint
        :param Sequence[str] scopes: a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[str]]:
        """
        a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        """
        a list of email domains of users authenticated by identity provider who are allowed access to the endpoint
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class EndpointConfigurationOauthProviderGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "emailDomains":
            suggest = "email_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationOauthProviderGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationOauthProviderGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationOauthProviderGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 email_addresses: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 organizations: Optional[Sequence[str]] = None,
                 scopes: Optional[Sequence[str]] = None,
                 teams: Optional[Sequence[str]] = None):
        """
        :param str client_id: the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.
        :param str client_secret: the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.
        :param Sequence[str] email_addresses: a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint
        :param Sequence[str] email_domains: a list of email domains of users authenticated by identity provider who are allowed access to the endpoint
        :param Sequence[str] organizations: a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'
        :param Sequence[str] scopes: a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)
        :param Sequence[str] teams: a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if organizations is not None:
            pulumi.set(__self__, "organizations", organizations)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[str]]:
        """
        a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        """
        a list of email domains of users authenticated by identity provider who are allowed access to the endpoint
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def organizations(self) -> Optional[Sequence[str]]:
        """
        a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'
        """
        return pulumi.get(self, "organizations")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence[str]]:
        """
        a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class EndpointConfigurationOauthProviderGoogle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "emailDomains":
            suggest = "email_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationOauthProviderGoogle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationOauthProviderGoogle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationOauthProviderGoogle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 email_addresses: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.
        :param str client_secret: the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.
        :param Sequence[str] email_addresses: a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint
        :param Sequence[str] email_domains: a list of email domains of users authenticated by identity provider who are allowed access to the endpoint
        :param Sequence[str] scopes: a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[str]]:
        """
        a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        """
        a list of email domains of users authenticated by identity provider who are allowed access to the endpoint
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class EndpointConfigurationOauthProviderMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "emailDomains":
            suggest = "email_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationOauthProviderMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationOauthProviderMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationOauthProviderMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 email_addresses: Optional[Sequence[str]] = None,
                 email_domains: Optional[Sequence[str]] = None,
                 scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.
        :param str client_secret: the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.
        :param Sequence[str] email_addresses: a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint
        :param Sequence[str] email_domains: a list of email domains of users authenticated by identity provider who are allowed access to the endpoint
        :param Sequence[str] scopes: a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_domains is not None:
            pulumi.set(__self__, "email_domains", email_domains)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[str]]:
        """
        a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter(name="emailDomains")
    def email_domains(self) -> Optional[Sequence[str]]:
        """
        a list of email domains of users authenticated by identity provider who are allowed access to the endpoint
        """
        return pulumi.get(self, "email_domains")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class EndpointConfigurationOidc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "cookiePrefix":
            suggest = "cookie_prefix"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "maximumDuration":
            suggest = "maximum_duration"
        elif key == "optionsPassthrough":
            suggest = "options_passthrough"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationOidc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationOidc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationOidc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 cookie_prefix: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 inactivity_timeout: Optional[int] = None,
                 issuer: Optional[str] = None,
                 maximum_duration: Optional[int] = None,
                 options_passthrough: Optional[bool] = None,
                 scopes: Optional[Sequence[str]] = None):
        """
        :param str client_id: The OIDC app's client ID and OIDC audience.
        :param str client_secret: The OIDC app's client secret.
        :param str cookie_prefix: the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param int inactivity_timeout: Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.
        :param str issuer: URL of the OIDC "OpenID provider". This is the base URL used for discovery.
        :param int maximum_duration: Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.
        :param bool options_passthrough: Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.
        :param Sequence[str] scopes: The set of scopes to request from the OIDC identity provider.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if cookie_prefix is not None:
            pulumi.set(__self__, "cookie_prefix", cookie_prefix)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if maximum_duration is not None:
            pulumi.set(__self__, "maximum_duration", maximum_duration)
        if options_passthrough is not None:
            pulumi.set(__self__, "options_passthrough", options_passthrough)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The OIDC app's client ID and OIDC audience.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OIDC app's client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="cookiePrefix")
    def cookie_prefix(self) -> Optional[str]:
        """
        the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'
        """
        return pulumi.get(self, "cookie_prefix")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[int]:
        """
        Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.
        """
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        URL of the OIDC "OpenID provider". This is the base URL used for discovery.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="maximumDuration")
    def maximum_duration(self) -> Optional[int]:
        """
        Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.
        """
        return pulumi.get(self, "maximum_duration")

    @property
    @pulumi.getter(name="optionsPassthrough")
    def options_passthrough(self) -> Optional[bool]:
        """
        Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.
        """
        return pulumi.get(self, "options_passthrough")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The set of scopes to request from the OIDC identity provider.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class EndpointConfigurationRequestHeader(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, str]] = None,
                 enabled: Optional[bool] = None,
                 removes: Optional[Sequence[str]] = None):
        """
        :param Mapping[str, str] add: a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param Sequence[str] removes: a list of header names that will be removed from the HTTP Request before being sent to the upstream application server
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if removes is not None:
            pulumi.set(__self__, "removes", removes)

    @property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, str]]:
        """
        a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def removes(self) -> Optional[Sequence[str]]:
        """
        a list of header names that will be removed from the HTTP Request before being sent to the upstream application server
        """
        return pulumi.get(self, "removes")


@pulumi.output_type
class EndpointConfigurationResponseHeader(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, str]] = None,
                 enabled: Optional[bool] = None,
                 removes: Optional[Sequence[str]] = None):
        """
        :param Mapping[str, str] add: a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param Sequence[str] removes: a list of header names that will be removed from the HTTP Response returned to the HTTP client
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if removes is not None:
            pulumi.set(__self__, "removes", removes)

    @property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, str]]:
        """
        a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def removes(self) -> Optional[Sequence[str]]:
        """
        a list of header names that will be removed from the HTTP Response returned to the HTTP client
        """
        return pulumi.get(self, "removes")


@pulumi.output_type
class EndpointConfigurationSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowIdpInitiated":
            suggest = "allow_idp_initiated"
        elif key == "assertionConsumerServiceUrl":
            suggest = "assertion_consumer_service_url"
        elif key == "authorizedGroups":
            suggest = "authorized_groups"
        elif key == "cookiePrefix":
            suggest = "cookie_prefix"
        elif key == "entityId":
            suggest = "entity_id"
        elif key == "forceAuthn":
            suggest = "force_authn"
        elif key == "idpMetadata":
            suggest = "idp_metadata"
        elif key == "idpMetadataUrl":
            suggest = "idp_metadata_url"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "maximumDuration":
            suggest = "maximum_duration"
        elif key == "metadataUrl":
            suggest = "metadata_url"
        elif key == "nameidFormat":
            suggest = "nameid_format"
        elif key == "optionsPassthrough":
            suggest = "options_passthrough"
        elif key == "requestSigningCertificatePem":
            suggest = "request_signing_certificate_pem"
        elif key == "singleLogoutUrl":
            suggest = "single_logout_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_idp_initiated: Optional[bool] = None,
                 assertion_consumer_service_url: Optional[str] = None,
                 authorized_groups: Optional[Sequence[str]] = None,
                 cookie_prefix: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 entity_id: Optional[str] = None,
                 force_authn: Optional[bool] = None,
                 idp_metadata: Optional[str] = None,
                 idp_metadata_url: Optional[str] = None,
                 inactivity_timeout: Optional[int] = None,
                 maximum_duration: Optional[int] = None,
                 metadata_url: Optional[str] = None,
                 nameid_format: Optional[str] = None,
                 options_passthrough: Optional[bool] = None,
                 request_signing_certificate_pem: Optional[str] = None,
                 single_logout_url: Optional[str] = None):
        """
        :param bool allow_idp_initiated: If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.
        :param str assertion_consumer_service_url: The public URL of the SP's Assertion Consumer Service. This is where the IdP will redirect to during an authentication flow. This will need to be specified to the IdP as configuration.
        :param Sequence[str] authorized_groups: If present, only users who are a member of one of the listed groups may access the target endpoint.
        :param str cookie_prefix: the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param str entity_id: The SP Entity's unique ID. This always takes the form of a URL. In ngrok's implementation, this URL is the same as the metadata URL. This will need to be specified to the IdP as configuration.
        :param bool force_authn: If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.
        :param str idp_metadata: The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.
        :param str idp_metadata_url: The IdP's metadata URL which returns the XML IdP EntityDescriptor. The IdP's metadata URL specifies how to connect to the IdP as well as its public key which is then used to validate the signature on incoming SAML assertions to the ACS endpoint.
        :param int inactivity_timeout: Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.
        :param int maximum_duration: Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.
        :param str metadata_url: A public URL where the SP's metadata is hosted. If an IdP supports dynamic configuration, this is the URL it can use to retrieve the SP metadata.
        :param str nameid_format: Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.
        :param bool options_passthrough: Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.
        :param str request_signing_certificate_pem: PEM-encoded x.509 certificate of the key pair that is used to sign all SAML requests that the ngrok SP makes to the IdP. Many IdPs do not support request signing verification, but we highly recommend specifying this in the IdP's configuration if it is supported.
        :param str single_logout_url: The public URL of the SP's Single Logout Service. This is where the IdP will redirect to during a single logout flow. This will optionally need to be specified to the IdP as configuration.
        """
        if allow_idp_initiated is not None:
            pulumi.set(__self__, "allow_idp_initiated", allow_idp_initiated)
        if assertion_consumer_service_url is not None:
            pulumi.set(__self__, "assertion_consumer_service_url", assertion_consumer_service_url)
        if authorized_groups is not None:
            pulumi.set(__self__, "authorized_groups", authorized_groups)
        if cookie_prefix is not None:
            pulumi.set(__self__, "cookie_prefix", cookie_prefix)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if force_authn is not None:
            pulumi.set(__self__, "force_authn", force_authn)
        if idp_metadata is not None:
            pulumi.set(__self__, "idp_metadata", idp_metadata)
        if idp_metadata_url is not None:
            pulumi.set(__self__, "idp_metadata_url", idp_metadata_url)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if maximum_duration is not None:
            pulumi.set(__self__, "maximum_duration", maximum_duration)
        if metadata_url is not None:
            pulumi.set(__self__, "metadata_url", metadata_url)
        if nameid_format is not None:
            pulumi.set(__self__, "nameid_format", nameid_format)
        if options_passthrough is not None:
            pulumi.set(__self__, "options_passthrough", options_passthrough)
        if request_signing_certificate_pem is not None:
            pulumi.set(__self__, "request_signing_certificate_pem", request_signing_certificate_pem)
        if single_logout_url is not None:
            pulumi.set(__self__, "single_logout_url", single_logout_url)

    @property
    @pulumi.getter(name="allowIdpInitiated")
    def allow_idp_initiated(self) -> Optional[bool]:
        """
        If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.
        """
        return pulumi.get(self, "allow_idp_initiated")

    @property
    @pulumi.getter(name="assertionConsumerServiceUrl")
    def assertion_consumer_service_url(self) -> Optional[str]:
        """
        The public URL of the SP's Assertion Consumer Service. This is where the IdP will redirect to during an authentication flow. This will need to be specified to the IdP as configuration.
        """
        return pulumi.get(self, "assertion_consumer_service_url")

    @property
    @pulumi.getter(name="authorizedGroups")
    def authorized_groups(self) -> Optional[Sequence[str]]:
        """
        If present, only users who are a member of one of the listed groups may access the target endpoint.
        """
        return pulumi.get(self, "authorized_groups")

    @property
    @pulumi.getter(name="cookiePrefix")
    def cookie_prefix(self) -> Optional[str]:
        """
        the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'
        """
        return pulumi.get(self, "cookie_prefix")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        """
        The SP Entity's unique ID. This always takes the form of a URL. In ngrok's implementation, this URL is the same as the metadata URL. This will need to be specified to the IdP as configuration.
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="forceAuthn")
    def force_authn(self) -> Optional[bool]:
        """
        If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.
        """
        return pulumi.get(self, "force_authn")

    @property
    @pulumi.getter(name="idpMetadata")
    def idp_metadata(self) -> Optional[str]:
        """
        The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.
        """
        return pulumi.get(self, "idp_metadata")

    @property
    @pulumi.getter(name="idpMetadataUrl")
    def idp_metadata_url(self) -> Optional[str]:
        """
        The IdP's metadata URL which returns the XML IdP EntityDescriptor. The IdP's metadata URL specifies how to connect to the IdP as well as its public key which is then used to validate the signature on incoming SAML assertions to the ACS endpoint.
        """
        return pulumi.get(self, "idp_metadata_url")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[int]:
        """
        Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.
        """
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter(name="maximumDuration")
    def maximum_duration(self) -> Optional[int]:
        """
        Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.
        """
        return pulumi.get(self, "maximum_duration")

    @property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> Optional[str]:
        """
        A public URL where the SP's metadata is hosted. If an IdP supports dynamic configuration, this is the URL it can use to retrieve the SP metadata.
        """
        return pulumi.get(self, "metadata_url")

    @property
    @pulumi.getter(name="nameidFormat")
    def nameid_format(self) -> Optional[str]:
        """
        Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.
        """
        return pulumi.get(self, "nameid_format")

    @property
    @pulumi.getter(name="optionsPassthrough")
    def options_passthrough(self) -> Optional[bool]:
        """
        Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.
        """
        return pulumi.get(self, "options_passthrough")

    @property
    @pulumi.getter(name="requestSigningCertificatePem")
    def request_signing_certificate_pem(self) -> Optional[str]:
        """
        PEM-encoded x.509 certificate of the key pair that is used to sign all SAML requests that the ngrok SP makes to the IdP. Many IdPs do not support request signing verification, but we highly recommend specifying this in the IdP's configuration if it is supported.
        """
        return pulumi.get(self, "request_signing_certificate_pem")

    @property
    @pulumi.getter(name="singleLogoutUrl")
    def single_logout_url(self) -> Optional[str]:
        """
        The public URL of the SP's Single Logout Service. This is where the IdP will redirect to during a single logout flow. This will optionally need to be specified to the IdP as configuration.
        """
        return pulumi.get(self, "single_logout_url")


@pulumi.output_type
class EndpointConfigurationTlsTermination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minVersion":
            suggest = "min_version"
        elif key == "terminateAt":
            suggest = "terminate_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationTlsTermination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationTlsTermination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationTlsTermination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 min_version: Optional[str] = None,
                 terminate_at: Optional[str] = None):
        """
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param str min_version: The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.
        :param str terminate_at: `edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if min_version is not None:
            pulumi.set(__self__, "min_version", min_version)
        if terminate_at is not None:
            pulumi.set(__self__, "terminate_at", terminate_at)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="minVersion")
    def min_version(self) -> Optional[str]:
        """
        The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.
        """
        return pulumi.get(self, "min_version")

    @property
    @pulumi.getter(name="terminateAt")
    def terminate_at(self) -> Optional[str]:
        """
        `edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.
        """
        return pulumi.get(self, "terminate_at")


@pulumi.output_type
class EndpointConfigurationWebhookValidation(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 provider: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param bool enabled: `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        :param str provider: a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers: `SLACK`, `SNS`, `STRIPE`, `GITHUB`, `TWILIO`, `SHOPIFY`, `GITLAB`, `INTERCOM`, `SENDGRID`, `XERO`, `PAGERDUTY`.
        :param str secret: a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers: `SLACK`, `SNS`, `STRIPE`, `GITHUB`, `TWILIO`, `SHOPIFY`, `GITLAB`, `INTERCOM`, `SENDGRID`, `XERO`, `PAGERDUTY`.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class EventDestinationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogs":
            suggest = "cloudwatch_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_logs: Optional[Sequence['outputs.EventDestinationTargetCloudwatchLog']] = None,
                 debugs: Optional[Sequence['outputs.EventDestinationTargetDebug']] = None,
                 firehoses: Optional[Sequence['outputs.EventDestinationTargetFirehose']] = None,
                 kineses: Optional[Sequence['outputs.EventDestinationTargetKinese']] = None):
        """
        :param Sequence['EventDestinationTargetCloudwatchLogArgs'] cloudwatch_logs: Configuration used to send events to Amazon CloudWatch Logs.
        :param Sequence['EventDestinationTargetDebugArgs'] debugs: Configuration used for internal debugging.
        :param Sequence['EventDestinationTargetFirehoseArgs'] firehoses: Configuration used to send events to Amazon Kinesis Data Firehose.
        :param Sequence['EventDestinationTargetKineseArgs'] kineses: Configuration used to send events to Amazon Kinesis.
        """
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if debugs is not None:
            pulumi.set(__self__, "debugs", debugs)
        if firehoses is not None:
            pulumi.set(__self__, "firehoses", firehoses)
        if kineses is not None:
            pulumi.set(__self__, "kineses", kineses)

    @property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[Sequence['outputs.EventDestinationTargetCloudwatchLog']]:
        """
        Configuration used to send events to Amazon CloudWatch Logs.
        """
        return pulumi.get(self, "cloudwatch_logs")

    @property
    @pulumi.getter
    def debugs(self) -> Optional[Sequence['outputs.EventDestinationTargetDebug']]:
        """
        Configuration used for internal debugging.
        """
        return pulumi.get(self, "debugs")

    @property
    @pulumi.getter
    def firehoses(self) -> Optional[Sequence['outputs.EventDestinationTargetFirehose']]:
        """
        Configuration used to send events to Amazon Kinesis Data Firehose.
        """
        return pulumi.get(self, "firehoses")

    @property
    @pulumi.getter
    def kineses(self) -> Optional[Sequence['outputs.EventDestinationTargetKinese']]:
        """
        Configuration used to send events to Amazon Kinesis.
        """
        return pulumi.get(self, "kineses")


@pulumi.output_type
class EventDestinationTargetCloudwatchLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupArn":
            suggest = "log_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetCloudwatchLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetCloudwatchLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetCloudwatchLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auths: Optional[Sequence['outputs.EventDestinationTargetCloudwatchLogAuth']] = None,
                 log_group_arn: Optional[str] = None):
        """
        :param Sequence['EventDestinationTargetCloudwatchLogAuthArgs'] auths: Configuration for how to authenticate into your AWS account. Exactly one of `role` or `creds` should be configured.
        :param str log_group_arn: An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.
        """
        if auths is not None:
            pulumi.set(__self__, "auths", auths)
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)

    @property
    @pulumi.getter
    def auths(self) -> Optional[Sequence['outputs.EventDestinationTargetCloudwatchLogAuth']]:
        """
        Configuration for how to authenticate into your AWS account. Exactly one of `role` or `creds` should be configured.
        """
        return pulumi.get(self, "auths")

    @property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[str]:
        """
        An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.
        """
        return pulumi.get(self, "log_group_arn")


@pulumi.output_type
class EventDestinationTargetCloudwatchLogAuth(dict):
    def __init__(__self__, *,
                 creds: Optional[Sequence['outputs.EventDestinationTargetCloudwatchLogAuthCred']] = None,
                 roles: Optional[Sequence['outputs.EventDestinationTargetCloudwatchLogAuthRole']] = None):
        """
        :param Sequence['EventDestinationTargetCloudwatchLogAuthCredArgs'] creds: Credentials to your AWS account if you prefer ngrok to sign in with long-term access keys.
        :param Sequence['EventDestinationTargetCloudwatchLogAuthRoleArgs'] roles: A role for ngrok to assume on your behalf to deposit events into your AWS account.
        """
        if creds is not None:
            pulumi.set(__self__, "creds", creds)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def creds(self) -> Optional[Sequence['outputs.EventDestinationTargetCloudwatchLogAuthCred']]:
        """
        Credentials to your AWS account if you prefer ngrok to sign in with long-term access keys.
        """
        return pulumi.get(self, "creds")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence['outputs.EventDestinationTargetCloudwatchLogAuthRole']]:
        """
        A role for ngrok to assume on your behalf to deposit events into your AWS account.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class EventDestinationTargetCloudwatchLogAuthCred(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetCloudwatchLogAuthCred. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetCloudwatchLogAuthCred.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetCloudwatchLogAuthCred.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: str,
                 aws_secret_access_key: str):
        """
        :param str aws_access_key_id: The ID portion of an AWS access key.
        :param str aws_secret_access_key: The secret portion of an AWS access key.
        """
        pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> str:
        """
        The ID portion of an AWS access key.
        """
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> str:
        """
        The secret portion of an AWS access key.
        """
        return pulumi.get(self, "aws_secret_access_key")


@pulumi.output_type
class EventDestinationTargetCloudwatchLogAuthRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetCloudwatchLogAuthRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetCloudwatchLogAuthRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetCloudwatchLogAuthRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str):
        """
        :param str role_arn: An ARN that specifies the role that ngrok should use to deliver to the configured target.
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        An ARN that specifies the role that ngrok should use to deliver to the configured target.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class EventDestinationTargetDebug(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "callbackUrl":
            suggest = "callback_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetDebug. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetDebug.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetDebug.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 callback_url: Optional[str] = None,
                 log: Optional[bool] = None):
        """
        :param str callback_url: URL to send events to.
        :param bool log: Whether or not to output to publisher service logs.
        """
        if callback_url is not None:
            pulumi.set(__self__, "callback_url", callback_url)
        if log is not None:
            pulumi.set(__self__, "log", log)

    @property
    @pulumi.getter(name="callbackUrl")
    def callback_url(self) -> Optional[str]:
        """
        URL to send events to.
        """
        return pulumi.get(self, "callback_url")

    @property
    @pulumi.getter
    def log(self) -> Optional[bool]:
        """
        Whether or not to output to publisher service logs.
        """
        return pulumi.get(self, "log")


@pulumi.output_type
class EventDestinationTargetFirehose(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryStreamArn":
            suggest = "delivery_stream_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetFirehose. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetFirehose.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetFirehose.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auths: Optional[Sequence['outputs.EventDestinationTargetFirehoseAuth']] = None,
                 delivery_stream_arn: Optional[str] = None):
        """
        :param Sequence['EventDestinationTargetFirehoseAuthArgs'] auths: Configuration for how to authenticate into your AWS account. Exactly one of `role` or `creds` should be configured.
        :param str delivery_stream_arn: An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.
        """
        if auths is not None:
            pulumi.set(__self__, "auths", auths)
        if delivery_stream_arn is not None:
            pulumi.set(__self__, "delivery_stream_arn", delivery_stream_arn)

    @property
    @pulumi.getter
    def auths(self) -> Optional[Sequence['outputs.EventDestinationTargetFirehoseAuth']]:
        """
        Configuration for how to authenticate into your AWS account. Exactly one of `role` or `creds` should be configured.
        """
        return pulumi.get(self, "auths")

    @property
    @pulumi.getter(name="deliveryStreamArn")
    def delivery_stream_arn(self) -> Optional[str]:
        """
        An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.
        """
        return pulumi.get(self, "delivery_stream_arn")


@pulumi.output_type
class EventDestinationTargetFirehoseAuth(dict):
    def __init__(__self__, *,
                 creds: Optional[Sequence['outputs.EventDestinationTargetFirehoseAuthCred']] = None,
                 roles: Optional[Sequence['outputs.EventDestinationTargetFirehoseAuthRole']] = None):
        """
        :param Sequence['EventDestinationTargetFirehoseAuthCredArgs'] creds: Credentials to your AWS account if you prefer ngrok to sign in with long-term access keys.
        :param Sequence['EventDestinationTargetFirehoseAuthRoleArgs'] roles: A role for ngrok to assume on your behalf to deposit events into your AWS account.
        """
        if creds is not None:
            pulumi.set(__self__, "creds", creds)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def creds(self) -> Optional[Sequence['outputs.EventDestinationTargetFirehoseAuthCred']]:
        """
        Credentials to your AWS account if you prefer ngrok to sign in with long-term access keys.
        """
        return pulumi.get(self, "creds")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence['outputs.EventDestinationTargetFirehoseAuthRole']]:
        """
        A role for ngrok to assume on your behalf to deposit events into your AWS account.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class EventDestinationTargetFirehoseAuthCred(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetFirehoseAuthCred. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetFirehoseAuthCred.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetFirehoseAuthCred.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: str,
                 aws_secret_access_key: str):
        """
        :param str aws_access_key_id: The ID portion of an AWS access key.
        :param str aws_secret_access_key: The secret portion of an AWS access key.
        """
        pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> str:
        """
        The ID portion of an AWS access key.
        """
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> str:
        """
        The secret portion of an AWS access key.
        """
        return pulumi.get(self, "aws_secret_access_key")


@pulumi.output_type
class EventDestinationTargetFirehoseAuthRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetFirehoseAuthRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetFirehoseAuthRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetFirehoseAuthRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str):
        """
        :param str role_arn: An ARN that specifies the role that ngrok should use to deliver to the configured target.
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        An ARN that specifies the role that ngrok should use to deliver to the configured target.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class EventDestinationTargetKinese(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamArn":
            suggest = "stream_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetKinese. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetKinese.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetKinese.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auths: Optional[Sequence['outputs.EventDestinationTargetKineseAuth']] = None,
                 stream_arn: Optional[str] = None):
        """
        :param Sequence['EventDestinationTargetKineseAuthArgs'] auths: Configuration for how to authenticate into your AWS account. Exactly one of `role` or `creds` should be configured.
        :param str stream_arn: An Amazon Resource Name specifying the Kinesis stream to deposit events into.
        """
        if auths is not None:
            pulumi.set(__self__, "auths", auths)
        if stream_arn is not None:
            pulumi.set(__self__, "stream_arn", stream_arn)

    @property
    @pulumi.getter
    def auths(self) -> Optional[Sequence['outputs.EventDestinationTargetKineseAuth']]:
        """
        Configuration for how to authenticate into your AWS account. Exactly one of `role` or `creds` should be configured.
        """
        return pulumi.get(self, "auths")

    @property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> Optional[str]:
        """
        An Amazon Resource Name specifying the Kinesis stream to deposit events into.
        """
        return pulumi.get(self, "stream_arn")


@pulumi.output_type
class EventDestinationTargetKineseAuth(dict):
    def __init__(__self__, *,
                 creds: Optional[Sequence['outputs.EventDestinationTargetKineseAuthCred']] = None,
                 roles: Optional[Sequence['outputs.EventDestinationTargetKineseAuthRole']] = None):
        """
        :param Sequence['EventDestinationTargetKineseAuthCredArgs'] creds: Credentials to your AWS account if you prefer ngrok to sign in with long-term access keys.
        :param Sequence['EventDestinationTargetKineseAuthRoleArgs'] roles: A role for ngrok to assume on your behalf to deposit events into your AWS account.
        """
        if creds is not None:
            pulumi.set(__self__, "creds", creds)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def creds(self) -> Optional[Sequence['outputs.EventDestinationTargetKineseAuthCred']]:
        """
        Credentials to your AWS account if you prefer ngrok to sign in with long-term access keys.
        """
        return pulumi.get(self, "creds")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence['outputs.EventDestinationTargetKineseAuthRole']]:
        """
        A role for ngrok to assume on your behalf to deposit events into your AWS account.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class EventDestinationTargetKineseAuthCred(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetKineseAuthCred. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetKineseAuthCred.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetKineseAuthCred.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: str,
                 aws_secret_access_key: str):
        """
        :param str aws_access_key_id: The ID portion of an AWS access key.
        :param str aws_secret_access_key: The secret portion of an AWS access key.
        """
        pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> str:
        """
        The ID portion of an AWS access key.
        """
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> str:
        """
        The secret portion of an AWS access key.
        """
        return pulumi.get(self, "aws_secret_access_key")


@pulumi.output_type
class EventDestinationTargetKineseAuthRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventDestinationTargetKineseAuthRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventDestinationTargetKineseAuthRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventDestinationTargetKineseAuthRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str):
        """
        :param str role_arn: An ARN that specifies the role that ngrok should use to deliver to the configured target.
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        An ARN that specifies the role that ngrok should use to deliver to the configured target.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class EventSubscriptionSource(dict):
    def __init__(__self__, *,
                 fields: Optional[Sequence[str]] = None,
                 filter: Optional[str] = None,
                 type: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param Sequence[str] fields: TODO
        :param str filter: TODO
        :param str type: Type of event for which an event subscription will trigger
        :param str uri: URI of the Event Source API resource.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[str]]:
        """
        TODO
        """
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        TODO
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of event for which an event subscription will trigger
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        URI of the Event Source API resource.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class ReservedDomainCertificateManagementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKeyType":
            suggest = "private_key_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservedDomainCertificateManagementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservedDomainCertificateManagementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservedDomainCertificateManagementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional[str] = None,
                 private_key_type: Optional[str] = None):
        """
        :param str authority: certificate authority to request certificates from. The only supported value is letsencrypt.
        :param str private_key_type: type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if private_key_type is not None:
            pulumi.set(__self__, "private_key_type", private_key_type)

    @property
    @pulumi.getter
    def authority(self) -> Optional[str]:
        """
        certificate authority to request certificates from. The only supported value is letsencrypt.
        """
        return pulumi.get(self, "authority")

    @property
    @pulumi.getter(name="privateKeyType")
    def private_key_type(self) -> Optional[str]:
        """
        type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.
        """
        return pulumi.get(self, "private_key_type")


@pulumi.output_type
class TlsCertificateSubjectAlternativeName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsNames":
            suggest = "dns_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TlsCertificateSubjectAlternativeName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TlsCertificateSubjectAlternativeName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TlsCertificateSubjectAlternativeName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_names: Optional[Sequence[str]] = None,
                 ips: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] dns_names: set of additional domains (including wildcards) this TLS certificate is valid for
        :param Sequence[str] ips: set of IP addresses this TLS certificate is also valid for
        """
        if dns_names is not None:
            pulumi.set(__self__, "dns_names", dns_names)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)

    @property
    @pulumi.getter(name="dnsNames")
    def dns_names(self) -> Optional[Sequence[str]]:
        """
        set of additional domains (including wildcards) this TLS certificate is valid for
        """
        return pulumi.get(self, "dns_names")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        set of IP addresses this TLS certificate is also valid for
        """
        return pulumi.get(self, "ips")


