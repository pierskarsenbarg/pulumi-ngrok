// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ngrok

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// TLS Certificates are pairs of x509 certificates and their matching private
//
//	key that can be used to terminate TLS traffic. TLS certificates are unused
//	until they are attached to a Domain. TLS Certificates may also be
//	provisioned by ngrok automatically for domains on which you have enabled
//	automated certificate provisioning.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-ngrok/sdk/go/ngrok"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := ngrok.NewTlsCertificate(ctx, "example", &ngrok.TlsCertificateArgs{
//				CertificatePem: pulumi.String(fmt.Sprintf(`-----BEGIN CERTIFICATE-----
//
// MIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL
// BQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw
// NDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN
// AQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4
// GANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL
// 7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR
// Al8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg
// LW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f
// rQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD
// VR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+
// zCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB
// AC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9
// tOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0
// oGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK
// 2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS
// 6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ
// d6JTpFbsCtwDjP23UEi7SZo=
// -----END CERTIFICATE-----
// `)),
//
//	PrivateKeyPem: pulumi.String(fmt.Sprintf(`-----BEGIN PRIVATE KEY-----
//
// MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDylZJCmDZd3fXK
// q8+LSBZcLKIRA+VuMtXXAYscuBgDRRZ8ON53NsD8isGF7piaiSBa3FvzZFGS9O23
// fnaLupk+hof822k1vdSJERD1y+29yn1buF5BaLFV6VrNFOqOBq2fNQi4igViPh9N
// 8f4o+TkoidZe9aai3kySzsnQEQJfJKae2sXh1OFGw6wGZFuUp7mU4yCsFYNFDbAY
// NcjX1DrtVGodwWGqj4EIrQtGIC1vjVBrv0/dW5A+7S7FSJ5EF3kBnVwQKjsnHye8
// I/DpSKcrl405xhQNIs1Zm0MOX60J2dIHhsoS2pr8/RnHe5iJQ//vwBDfS4bfNrQD
// syhvfPzvAgMBAAECggEBALLv7YE98exvi5zB+0fMFuJK8gkHDLequ93q/4hhqyTO
// U3WyJTdepiAi4fk/NEXZnIopPZJdj2aNUMQnfp43OE7MwYac+hBwRFQOyKnmkSmM
// Mcf0SWKKLTUn+piIMzQsbOmhHxuwg6QiGslOFaJ3o9fpRL2rCg3dWDJ6Ypcd1NgE
// K0uy7gg+DwIpU6MeG6lA+HbxbGi+yd2x88Gjn9dGr7FZK34RUDooH60BCX9P8N9X
// T+n10MzzX7ZQOsLfe8FKc1/X8AybI5SYm1GMyfKD4QBt6JG4HKAjPHzBzcIpfN3d
// 7BM11Imkrz7LcbUG+F23NVsi6n5IIGT1WqwCRIH2PpECgYEA/SJ5Ra4d0hUS5RYB
// zABquM3sp7JsKxCn7O5PqNLB4TgH9dXtWFhaFVB6juMGyHbvktVH0j4lps/Te0rk
// VU2zU1XxvCTFhtcCYUtNk0cRw6LH8feKiorXHdDRB33t0c47QSD/6AGOjBtxqD7B
// 3ZxyR3P+7RdQopLLRFN+FHAnmzsCgYEA9VSGZDFSK+fbg4CgwkWdzuHrAXaUEv0U
// ovqqWd/yXB9wauEvRHnOrSgW6hFZQiatJOXx0KnalJQzohz/SLGO0MqGtwQbYWVT
// WiJgjUbNeiPEHBeUA6U55lVQr26kQSUWdXEtRbDz+hqV1K+6tTEMzaSPmJiHNgki
// lNMO2gqGQd0CgYBJ268qx5zn2UJEGWG41j5NYbg1TfgFsLxugzI2/heX0TNxZVP1
// PQI7ydmYq2ElSJ6qZxSnoX5255i7FqT8xskV/bOkw83mhAGrxb8Cw+/I90wDq8h+
// l/ggOPdkijfDybq8TBae6SVgd/l3r6f9M1KcypmNMApVBSPN8daNvBOyVQKBgQDo
// sj2utyFrx8Xsm4rf+kxOuPbBMooM4MQ8OmpuSP6G5sMofWLqHmcs0sO5TK9PEYRV
// ZU3ST+ml2FSJRdvWRaRi4laZLWoTHZrL+aN/HVM0sMwIoUyhkIy0ruOTIuzlZZpB
// 1xHL8qXX6nOHgw8jYdz1CUuyv6owVMXaR77kjer+eQKBgByYZlR/eNTzlot0SdFl
// IbgQ9bV7VLIo+vKzOXE3trfzRJMgUosLTp+5wdSVSW/VBdYZ7Ir3n0bbpY/dGinI
// VShxPbChhCZnhvG2lEEiekI44m5jHSA6hhtRdt/CrhL65Rw2SE5lMEe8htg1UGus
// wzLHWHBl72FjbjdhvEgrq60W
// -----END PRIVATE KEY-----
// `)),
//
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type TlsCertificate struct {
	pulumi.CustomResourceState

	// chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).
	CertificatePem pulumi.StringOutput `pulumi:"certificatePem"`
	// human-readable description of this TLS certificate. optional, max 255 bytes.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.
	Metadata pulumi.StringPtrOutput `pulumi:"metadata"`
	// private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).
	PrivateKeyPem pulumi.StringOutput `pulumi:"privateKeyPem"`
	// subject alternative names (SANs) from the leaf of this TLS certificate
	SubjectAlternativeNames TlsCertificateSubjectAlternativeNameArrayOutput `pulumi:"subjectAlternativeNames"`
}

// NewTlsCertificate registers a new resource with the given unique name, arguments, and options.
func NewTlsCertificate(ctx *pulumi.Context,
	name string, args *TlsCertificateArgs, opts ...pulumi.ResourceOption) (*TlsCertificate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CertificatePem == nil {
		return nil, errors.New("invalid value for required argument 'CertificatePem'")
	}
	if args.PrivateKeyPem == nil {
		return nil, errors.New("invalid value for required argument 'PrivateKeyPem'")
	}
	var resource TlsCertificate
	err := ctx.RegisterResource("ngrok:index/tlsCertificate:TlsCertificate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTlsCertificate gets an existing TlsCertificate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTlsCertificate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TlsCertificateState, opts ...pulumi.ResourceOption) (*TlsCertificate, error) {
	var resource TlsCertificate
	err := ctx.ReadResource("ngrok:index/tlsCertificate:TlsCertificate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TlsCertificate resources.
type tlsCertificateState struct {
	// chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).
	CertificatePem *string `pulumi:"certificatePem"`
	// human-readable description of this TLS certificate. optional, max 255 bytes.
	Description *string `pulumi:"description"`
	// arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.
	Metadata *string `pulumi:"metadata"`
	// private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).
	PrivateKeyPem *string `pulumi:"privateKeyPem"`
	// subject alternative names (SANs) from the leaf of this TLS certificate
	SubjectAlternativeNames []TlsCertificateSubjectAlternativeName `pulumi:"subjectAlternativeNames"`
}

type TlsCertificateState struct {
	// chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).
	CertificatePem pulumi.StringPtrInput
	// human-readable description of this TLS certificate. optional, max 255 bytes.
	Description pulumi.StringPtrInput
	// arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.
	Metadata pulumi.StringPtrInput
	// private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).
	PrivateKeyPem pulumi.StringPtrInput
	// subject alternative names (SANs) from the leaf of this TLS certificate
	SubjectAlternativeNames TlsCertificateSubjectAlternativeNameArrayInput
}

func (TlsCertificateState) ElementType() reflect.Type {
	return reflect.TypeOf((*tlsCertificateState)(nil)).Elem()
}

type tlsCertificateArgs struct {
	// chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).
	CertificatePem string `pulumi:"certificatePem"`
	// human-readable description of this TLS certificate. optional, max 255 bytes.
	Description *string `pulumi:"description"`
	// arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.
	Metadata *string `pulumi:"metadata"`
	// private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).
	PrivateKeyPem string `pulumi:"privateKeyPem"`
	// subject alternative names (SANs) from the leaf of this TLS certificate
	SubjectAlternativeNames []TlsCertificateSubjectAlternativeName `pulumi:"subjectAlternativeNames"`
}

// The set of arguments for constructing a TlsCertificate resource.
type TlsCertificateArgs struct {
	// chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).
	CertificatePem pulumi.StringInput
	// human-readable description of this TLS certificate. optional, max 255 bytes.
	Description pulumi.StringPtrInput
	// arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.
	Metadata pulumi.StringPtrInput
	// private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).
	PrivateKeyPem pulumi.StringInput
	// subject alternative names (SANs) from the leaf of this TLS certificate
	SubjectAlternativeNames TlsCertificateSubjectAlternativeNameArrayInput
}

func (TlsCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*tlsCertificateArgs)(nil)).Elem()
}

type TlsCertificateInput interface {
	pulumi.Input

	ToTlsCertificateOutput() TlsCertificateOutput
	ToTlsCertificateOutputWithContext(ctx context.Context) TlsCertificateOutput
}

func (*TlsCertificate) ElementType() reflect.Type {
	return reflect.TypeOf((**TlsCertificate)(nil)).Elem()
}

func (i *TlsCertificate) ToTlsCertificateOutput() TlsCertificateOutput {
	return i.ToTlsCertificateOutputWithContext(context.Background())
}

func (i *TlsCertificate) ToTlsCertificateOutputWithContext(ctx context.Context) TlsCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsCertificateOutput)
}

// TlsCertificateArrayInput is an input type that accepts TlsCertificateArray and TlsCertificateArrayOutput values.
// You can construct a concrete instance of `TlsCertificateArrayInput` via:
//
//	TlsCertificateArray{ TlsCertificateArgs{...} }
type TlsCertificateArrayInput interface {
	pulumi.Input

	ToTlsCertificateArrayOutput() TlsCertificateArrayOutput
	ToTlsCertificateArrayOutputWithContext(context.Context) TlsCertificateArrayOutput
}

type TlsCertificateArray []TlsCertificateInput

func (TlsCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TlsCertificate)(nil)).Elem()
}

func (i TlsCertificateArray) ToTlsCertificateArrayOutput() TlsCertificateArrayOutput {
	return i.ToTlsCertificateArrayOutputWithContext(context.Background())
}

func (i TlsCertificateArray) ToTlsCertificateArrayOutputWithContext(ctx context.Context) TlsCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsCertificateArrayOutput)
}

// TlsCertificateMapInput is an input type that accepts TlsCertificateMap and TlsCertificateMapOutput values.
// You can construct a concrete instance of `TlsCertificateMapInput` via:
//
//	TlsCertificateMap{ "key": TlsCertificateArgs{...} }
type TlsCertificateMapInput interface {
	pulumi.Input

	ToTlsCertificateMapOutput() TlsCertificateMapOutput
	ToTlsCertificateMapOutputWithContext(context.Context) TlsCertificateMapOutput
}

type TlsCertificateMap map[string]TlsCertificateInput

func (TlsCertificateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TlsCertificate)(nil)).Elem()
}

func (i TlsCertificateMap) ToTlsCertificateMapOutput() TlsCertificateMapOutput {
	return i.ToTlsCertificateMapOutputWithContext(context.Background())
}

func (i TlsCertificateMap) ToTlsCertificateMapOutputWithContext(ctx context.Context) TlsCertificateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsCertificateMapOutput)
}

type TlsCertificateOutput struct{ *pulumi.OutputState }

func (TlsCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TlsCertificate)(nil)).Elem()
}

func (o TlsCertificateOutput) ToTlsCertificateOutput() TlsCertificateOutput {
	return o
}

func (o TlsCertificateOutput) ToTlsCertificateOutputWithContext(ctx context.Context) TlsCertificateOutput {
	return o
}

// chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).
func (o TlsCertificateOutput) CertificatePem() pulumi.StringOutput {
	return o.ApplyT(func(v *TlsCertificate) pulumi.StringOutput { return v.CertificatePem }).(pulumi.StringOutput)
}

// human-readable description of this TLS certificate. optional, max 255 bytes.
func (o TlsCertificateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TlsCertificate) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.
func (o TlsCertificateOutput) Metadata() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TlsCertificate) pulumi.StringPtrOutput { return v.Metadata }).(pulumi.StringPtrOutput)
}

// private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).
func (o TlsCertificateOutput) PrivateKeyPem() pulumi.StringOutput {
	return o.ApplyT(func(v *TlsCertificate) pulumi.StringOutput { return v.PrivateKeyPem }).(pulumi.StringOutput)
}

// subject alternative names (SANs) from the leaf of this TLS certificate
func (o TlsCertificateOutput) SubjectAlternativeNames() TlsCertificateSubjectAlternativeNameArrayOutput {
	return o.ApplyT(func(v *TlsCertificate) TlsCertificateSubjectAlternativeNameArrayOutput {
		return v.SubjectAlternativeNames
	}).(TlsCertificateSubjectAlternativeNameArrayOutput)
}

type TlsCertificateArrayOutput struct{ *pulumi.OutputState }

func (TlsCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TlsCertificate)(nil)).Elem()
}

func (o TlsCertificateArrayOutput) ToTlsCertificateArrayOutput() TlsCertificateArrayOutput {
	return o
}

func (o TlsCertificateArrayOutput) ToTlsCertificateArrayOutputWithContext(ctx context.Context) TlsCertificateArrayOutput {
	return o
}

func (o TlsCertificateArrayOutput) Index(i pulumi.IntInput) TlsCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TlsCertificate {
		return vs[0].([]*TlsCertificate)[vs[1].(int)]
	}).(TlsCertificateOutput)
}

type TlsCertificateMapOutput struct{ *pulumi.OutputState }

func (TlsCertificateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TlsCertificate)(nil)).Elem()
}

func (o TlsCertificateMapOutput) ToTlsCertificateMapOutput() TlsCertificateMapOutput {
	return o
}

func (o TlsCertificateMapOutput) ToTlsCertificateMapOutputWithContext(ctx context.Context) TlsCertificateMapOutput {
	return o
}

func (o TlsCertificateMapOutput) MapIndex(k pulumi.StringInput) TlsCertificateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TlsCertificate {
		return vs[0].(map[string]*TlsCertificate)[vs[1].(string)]
	}).(TlsCertificateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TlsCertificateInput)(nil)).Elem(), &TlsCertificate{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsCertificateArrayInput)(nil)).Elem(), TlsCertificateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsCertificateMapInput)(nil)).Elem(), TlsCertificateMap{})
	pulumi.RegisterOutputType(TlsCertificateOutput{})
	pulumi.RegisterOutputType(TlsCertificateArrayOutput{})
	pulumi.RegisterOutputType(TlsCertificateMapOutput{})
}
