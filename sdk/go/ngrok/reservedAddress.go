// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ngrok

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-ngrok/sdk/go/ngrok/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Reserved Addresses are TCP addresses that can be used to listen for traffic.
//
//	TCP address hostnames and ports are assigned by ngrok, they cannot be
//	chosen.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-ngrok/sdk/go/ngrok"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := ngrok.NewReservedAddress(ctx, "example", &ngrok.ReservedAddressArgs{
//				Description: pulumi.String("SSH for device #001"),
//				Region:      pulumi.String("us"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type ReservedAddress struct {
	pulumi.CustomResourceState

	// hostname:port of the reserved address that was assigned at creation time
	Addr pulumi.StringOutput `pulumi:"addr"`
	// human-readable description of what this reserved address will be used for
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// ID of an endpoint configuration of type tcp that will be used to handle inbound traffic to this address
	EndpointConfigurationId pulumi.StringPtrOutput `pulumi:"endpointConfigurationId"`
	// arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.
	Metadata pulumi.StringPtrOutput `pulumi:"metadata"`
	// reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)
	Region pulumi.StringPtrOutput `pulumi:"region"`
}

// NewReservedAddress registers a new resource with the given unique name, arguments, and options.
func NewReservedAddress(ctx *pulumi.Context,
	name string, args *ReservedAddressArgs, opts ...pulumi.ResourceOption) (*ReservedAddress, error) {
	if args == nil {
		args = &ReservedAddressArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ReservedAddress
	err := ctx.RegisterResource("ngrok:index/reservedAddress:ReservedAddress", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetReservedAddress gets an existing ReservedAddress resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetReservedAddress(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ReservedAddressState, opts ...pulumi.ResourceOption) (*ReservedAddress, error) {
	var resource ReservedAddress
	err := ctx.ReadResource("ngrok:index/reservedAddress:ReservedAddress", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ReservedAddress resources.
type reservedAddressState struct {
	// hostname:port of the reserved address that was assigned at creation time
	Addr *string `pulumi:"addr"`
	// human-readable description of what this reserved address will be used for
	Description *string `pulumi:"description"`
	// ID of an endpoint configuration of type tcp that will be used to handle inbound traffic to this address
	EndpointConfigurationId *string `pulumi:"endpointConfigurationId"`
	// arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.
	Metadata *string `pulumi:"metadata"`
	// reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)
	Region *string `pulumi:"region"`
}

type ReservedAddressState struct {
	// hostname:port of the reserved address that was assigned at creation time
	Addr pulumi.StringPtrInput
	// human-readable description of what this reserved address will be used for
	Description pulumi.StringPtrInput
	// ID of an endpoint configuration of type tcp that will be used to handle inbound traffic to this address
	EndpointConfigurationId pulumi.StringPtrInput
	// arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.
	Metadata pulumi.StringPtrInput
	// reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)
	Region pulumi.StringPtrInput
}

func (ReservedAddressState) ElementType() reflect.Type {
	return reflect.TypeOf((*reservedAddressState)(nil)).Elem()
}

type reservedAddressArgs struct {
	// hostname:port of the reserved address that was assigned at creation time
	Addr *string `pulumi:"addr"`
	// human-readable description of what this reserved address will be used for
	Description *string `pulumi:"description"`
	// ID of an endpoint configuration of type tcp that will be used to handle inbound traffic to this address
	EndpointConfigurationId *string `pulumi:"endpointConfigurationId"`
	// arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.
	Metadata *string `pulumi:"metadata"`
	// reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)
	Region *string `pulumi:"region"`
}

// The set of arguments for constructing a ReservedAddress resource.
type ReservedAddressArgs struct {
	// hostname:port of the reserved address that was assigned at creation time
	Addr pulumi.StringPtrInput
	// human-readable description of what this reserved address will be used for
	Description pulumi.StringPtrInput
	// ID of an endpoint configuration of type tcp that will be used to handle inbound traffic to this address
	EndpointConfigurationId pulumi.StringPtrInput
	// arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.
	Metadata pulumi.StringPtrInput
	// reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)
	Region pulumi.StringPtrInput
}

func (ReservedAddressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*reservedAddressArgs)(nil)).Elem()
}

type ReservedAddressInput interface {
	pulumi.Input

	ToReservedAddressOutput() ReservedAddressOutput
	ToReservedAddressOutputWithContext(ctx context.Context) ReservedAddressOutput
}

func (*ReservedAddress) ElementType() reflect.Type {
	return reflect.TypeOf((**ReservedAddress)(nil)).Elem()
}

func (i *ReservedAddress) ToReservedAddressOutput() ReservedAddressOutput {
	return i.ToReservedAddressOutputWithContext(context.Background())
}

func (i *ReservedAddress) ToReservedAddressOutputWithContext(ctx context.Context) ReservedAddressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReservedAddressOutput)
}

func (i *ReservedAddress) ToOutput(ctx context.Context) pulumix.Output[*ReservedAddress] {
	return pulumix.Output[*ReservedAddress]{
		OutputState: i.ToReservedAddressOutputWithContext(ctx).OutputState,
	}
}

// ReservedAddressArrayInput is an input type that accepts ReservedAddressArray and ReservedAddressArrayOutput values.
// You can construct a concrete instance of `ReservedAddressArrayInput` via:
//
//	ReservedAddressArray{ ReservedAddressArgs{...} }
type ReservedAddressArrayInput interface {
	pulumi.Input

	ToReservedAddressArrayOutput() ReservedAddressArrayOutput
	ToReservedAddressArrayOutputWithContext(context.Context) ReservedAddressArrayOutput
}

type ReservedAddressArray []ReservedAddressInput

func (ReservedAddressArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReservedAddress)(nil)).Elem()
}

func (i ReservedAddressArray) ToReservedAddressArrayOutput() ReservedAddressArrayOutput {
	return i.ToReservedAddressArrayOutputWithContext(context.Background())
}

func (i ReservedAddressArray) ToReservedAddressArrayOutputWithContext(ctx context.Context) ReservedAddressArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReservedAddressArrayOutput)
}

func (i ReservedAddressArray) ToOutput(ctx context.Context) pulumix.Output[[]*ReservedAddress] {
	return pulumix.Output[[]*ReservedAddress]{
		OutputState: i.ToReservedAddressArrayOutputWithContext(ctx).OutputState,
	}
}

// ReservedAddressMapInput is an input type that accepts ReservedAddressMap and ReservedAddressMapOutput values.
// You can construct a concrete instance of `ReservedAddressMapInput` via:
//
//	ReservedAddressMap{ "key": ReservedAddressArgs{...} }
type ReservedAddressMapInput interface {
	pulumi.Input

	ToReservedAddressMapOutput() ReservedAddressMapOutput
	ToReservedAddressMapOutputWithContext(context.Context) ReservedAddressMapOutput
}

type ReservedAddressMap map[string]ReservedAddressInput

func (ReservedAddressMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReservedAddress)(nil)).Elem()
}

func (i ReservedAddressMap) ToReservedAddressMapOutput() ReservedAddressMapOutput {
	return i.ToReservedAddressMapOutputWithContext(context.Background())
}

func (i ReservedAddressMap) ToReservedAddressMapOutputWithContext(ctx context.Context) ReservedAddressMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReservedAddressMapOutput)
}

func (i ReservedAddressMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*ReservedAddress] {
	return pulumix.Output[map[string]*ReservedAddress]{
		OutputState: i.ToReservedAddressMapOutputWithContext(ctx).OutputState,
	}
}

type ReservedAddressOutput struct{ *pulumi.OutputState }

func (ReservedAddressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReservedAddress)(nil)).Elem()
}

func (o ReservedAddressOutput) ToReservedAddressOutput() ReservedAddressOutput {
	return o
}

func (o ReservedAddressOutput) ToReservedAddressOutputWithContext(ctx context.Context) ReservedAddressOutput {
	return o
}

func (o ReservedAddressOutput) ToOutput(ctx context.Context) pulumix.Output[*ReservedAddress] {
	return pulumix.Output[*ReservedAddress]{
		OutputState: o.OutputState,
	}
}

// hostname:port of the reserved address that was assigned at creation time
func (o ReservedAddressOutput) Addr() pulumi.StringOutput {
	return o.ApplyT(func(v *ReservedAddress) pulumi.StringOutput { return v.Addr }).(pulumi.StringOutput)
}

// human-readable description of what this reserved address will be used for
func (o ReservedAddressOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReservedAddress) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// ID of an endpoint configuration of type tcp that will be used to handle inbound traffic to this address
func (o ReservedAddressOutput) EndpointConfigurationId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReservedAddress) pulumi.StringPtrOutput { return v.EndpointConfigurationId }).(pulumi.StringPtrOutput)
}

// arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.
func (o ReservedAddressOutput) Metadata() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReservedAddress) pulumi.StringPtrOutput { return v.Metadata }).(pulumi.StringPtrOutput)
}

// reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)
func (o ReservedAddressOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReservedAddress) pulumi.StringPtrOutput { return v.Region }).(pulumi.StringPtrOutput)
}

type ReservedAddressArrayOutput struct{ *pulumi.OutputState }

func (ReservedAddressArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReservedAddress)(nil)).Elem()
}

func (o ReservedAddressArrayOutput) ToReservedAddressArrayOutput() ReservedAddressArrayOutput {
	return o
}

func (o ReservedAddressArrayOutput) ToReservedAddressArrayOutputWithContext(ctx context.Context) ReservedAddressArrayOutput {
	return o
}

func (o ReservedAddressArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*ReservedAddress] {
	return pulumix.Output[[]*ReservedAddress]{
		OutputState: o.OutputState,
	}
}

func (o ReservedAddressArrayOutput) Index(i pulumi.IntInput) ReservedAddressOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ReservedAddress {
		return vs[0].([]*ReservedAddress)[vs[1].(int)]
	}).(ReservedAddressOutput)
}

type ReservedAddressMapOutput struct{ *pulumi.OutputState }

func (ReservedAddressMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReservedAddress)(nil)).Elem()
}

func (o ReservedAddressMapOutput) ToReservedAddressMapOutput() ReservedAddressMapOutput {
	return o
}

func (o ReservedAddressMapOutput) ToReservedAddressMapOutputWithContext(ctx context.Context) ReservedAddressMapOutput {
	return o
}

func (o ReservedAddressMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*ReservedAddress] {
	return pulumix.Output[map[string]*ReservedAddress]{
		OutputState: o.OutputState,
	}
}

func (o ReservedAddressMapOutput) MapIndex(k pulumi.StringInput) ReservedAddressOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ReservedAddress {
		return vs[0].(map[string]*ReservedAddress)[vs[1].(string)]
	}).(ReservedAddressOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ReservedAddressInput)(nil)).Elem(), &ReservedAddress{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReservedAddressArrayInput)(nil)).Elem(), ReservedAddressArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReservedAddressMapInput)(nil)).Elem(), ReservedAddressMap{})
	pulumi.RegisterOutputType(ReservedAddressOutput{})
	pulumi.RegisterOutputType(ReservedAddressArrayOutput{})
	pulumi.RegisterOutputType(ReservedAddressMapOutput{})
}
