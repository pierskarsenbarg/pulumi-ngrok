// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ngrok

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-ngrok/sdk/go/ngrok/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// SSH Credentials are SSH public keys that can be used to start SSH tunnels
//
//	via the ngrok SSH tunnel gateway.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-ngrok/sdk/go/ngrok"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := ngrok.NewSshCredential(ctx, "example", &ngrok.SshCredentialArgs{
//				Acls: pulumi.StringArray{
//					pulumi.String("bind:1.tcp.ngrok.io:20002"),
//					pulumi.String("bind:132.devices.company.com"),
//				},
//				Description: pulumi.String("for device #132"),
//				PublicKey:   pulumi.String("ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDmGS49FkSODAcKhn3+/47DW2zEn19BZvzRQ8RZjL3v6hCIX2qXfsFK35EGxNI0wV23H4xXC2gVRPHKU71YnCb50tad3yMBTM6+2yfGsEDasEH/anmBLclChKvuGiT547RskZlpbAbdq3GvbzmY+R/2EBRMOiObpc8XmSzKAd05j28kqN0+rZO65SWId0MXdvJdSCSAnuRqBNd/aXKlu8hBPDcgwbT2lMkuR+ApoBS2FLRBOiQyt2Ol0T7Uuf7lTLlazpGB3uTw5zFYUNXkuuI6cAP8QYuY1Bne/hNrG8t3Aw9a1yc2C4Fz1hJ/4OMRxTQ8SUQf+Rmxs8DryMlMFJ8r device132@example.com"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type SshCredential struct {
	pulumi.CustomResourceState

	// optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.
	Acls pulumi.StringArrayOutput `pulumi:"acls"`
	// human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.
	Metadata pulumi.StringPtrOutput `pulumi:"metadata"`
	// the PEM-encoded public key of the SSH keypair that will be used to authenticate
	PublicKey pulumi.StringOutput `pulumi:"publicKey"`
}

// NewSshCredential registers a new resource with the given unique name, arguments, and options.
func NewSshCredential(ctx *pulumi.Context,
	name string, args *SshCredentialArgs, opts ...pulumi.ResourceOption) (*SshCredential, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.PublicKey == nil {
		return nil, errors.New("invalid value for required argument 'PublicKey'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SshCredential
	err := ctx.RegisterResource("ngrok:index/sshCredential:SshCredential", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSshCredential gets an existing SshCredential resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSshCredential(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SshCredentialState, opts ...pulumi.ResourceOption) (*SshCredential, error) {
	var resource SshCredential
	err := ctx.ReadResource("ngrok:index/sshCredential:SshCredential", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SshCredential resources.
type sshCredentialState struct {
	// optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.
	Acls []string `pulumi:"acls"`
	// human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.
	Description *string `pulumi:"description"`
	// arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.
	Metadata *string `pulumi:"metadata"`
	// the PEM-encoded public key of the SSH keypair that will be used to authenticate
	PublicKey *string `pulumi:"publicKey"`
}

type SshCredentialState struct {
	// optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.
	Acls pulumi.StringArrayInput
	// human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.
	Description pulumi.StringPtrInput
	// arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.
	Metadata pulumi.StringPtrInput
	// the PEM-encoded public key of the SSH keypair that will be used to authenticate
	PublicKey pulumi.StringPtrInput
}

func (SshCredentialState) ElementType() reflect.Type {
	return reflect.TypeOf((*sshCredentialState)(nil)).Elem()
}

type sshCredentialArgs struct {
	// optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.
	Acls []string `pulumi:"acls"`
	// human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.
	Description *string `pulumi:"description"`
	// arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.
	Metadata *string `pulumi:"metadata"`
	// the PEM-encoded public key of the SSH keypair that will be used to authenticate
	PublicKey string `pulumi:"publicKey"`
}

// The set of arguments for constructing a SshCredential resource.
type SshCredentialArgs struct {
	// optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.
	Acls pulumi.StringArrayInput
	// human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.
	Description pulumi.StringPtrInput
	// arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.
	Metadata pulumi.StringPtrInput
	// the PEM-encoded public key of the SSH keypair that will be used to authenticate
	PublicKey pulumi.StringInput
}

func (SshCredentialArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sshCredentialArgs)(nil)).Elem()
}

type SshCredentialInput interface {
	pulumi.Input

	ToSshCredentialOutput() SshCredentialOutput
	ToSshCredentialOutputWithContext(ctx context.Context) SshCredentialOutput
}

func (*SshCredential) ElementType() reflect.Type {
	return reflect.TypeOf((**SshCredential)(nil)).Elem()
}

func (i *SshCredential) ToSshCredentialOutput() SshCredentialOutput {
	return i.ToSshCredentialOutputWithContext(context.Background())
}

func (i *SshCredential) ToSshCredentialOutputWithContext(ctx context.Context) SshCredentialOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SshCredentialOutput)
}

// SshCredentialArrayInput is an input type that accepts SshCredentialArray and SshCredentialArrayOutput values.
// You can construct a concrete instance of `SshCredentialArrayInput` via:
//
//	SshCredentialArray{ SshCredentialArgs{...} }
type SshCredentialArrayInput interface {
	pulumi.Input

	ToSshCredentialArrayOutput() SshCredentialArrayOutput
	ToSshCredentialArrayOutputWithContext(context.Context) SshCredentialArrayOutput
}

type SshCredentialArray []SshCredentialInput

func (SshCredentialArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SshCredential)(nil)).Elem()
}

func (i SshCredentialArray) ToSshCredentialArrayOutput() SshCredentialArrayOutput {
	return i.ToSshCredentialArrayOutputWithContext(context.Background())
}

func (i SshCredentialArray) ToSshCredentialArrayOutputWithContext(ctx context.Context) SshCredentialArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SshCredentialArrayOutput)
}

// SshCredentialMapInput is an input type that accepts SshCredentialMap and SshCredentialMapOutput values.
// You can construct a concrete instance of `SshCredentialMapInput` via:
//
//	SshCredentialMap{ "key": SshCredentialArgs{...} }
type SshCredentialMapInput interface {
	pulumi.Input

	ToSshCredentialMapOutput() SshCredentialMapOutput
	ToSshCredentialMapOutputWithContext(context.Context) SshCredentialMapOutput
}

type SshCredentialMap map[string]SshCredentialInput

func (SshCredentialMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SshCredential)(nil)).Elem()
}

func (i SshCredentialMap) ToSshCredentialMapOutput() SshCredentialMapOutput {
	return i.ToSshCredentialMapOutputWithContext(context.Background())
}

func (i SshCredentialMap) ToSshCredentialMapOutputWithContext(ctx context.Context) SshCredentialMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SshCredentialMapOutput)
}

type SshCredentialOutput struct{ *pulumi.OutputState }

func (SshCredentialOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SshCredential)(nil)).Elem()
}

func (o SshCredentialOutput) ToSshCredentialOutput() SshCredentialOutput {
	return o
}

func (o SshCredentialOutput) ToSshCredentialOutputWithContext(ctx context.Context) SshCredentialOutput {
	return o
}

// optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.
func (o SshCredentialOutput) Acls() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SshCredential) pulumi.StringArrayOutput { return v.Acls }).(pulumi.StringArrayOutput)
}

// human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.
func (o SshCredentialOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshCredential) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.
func (o SshCredentialOutput) Metadata() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshCredential) pulumi.StringPtrOutput { return v.Metadata }).(pulumi.StringPtrOutput)
}

// the PEM-encoded public key of the SSH keypair that will be used to authenticate
func (o SshCredentialOutput) PublicKey() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCredential) pulumi.StringOutput { return v.PublicKey }).(pulumi.StringOutput)
}

type SshCredentialArrayOutput struct{ *pulumi.OutputState }

func (SshCredentialArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SshCredential)(nil)).Elem()
}

func (o SshCredentialArrayOutput) ToSshCredentialArrayOutput() SshCredentialArrayOutput {
	return o
}

func (o SshCredentialArrayOutput) ToSshCredentialArrayOutputWithContext(ctx context.Context) SshCredentialArrayOutput {
	return o
}

func (o SshCredentialArrayOutput) Index(i pulumi.IntInput) SshCredentialOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SshCredential {
		return vs[0].([]*SshCredential)[vs[1].(int)]
	}).(SshCredentialOutput)
}

type SshCredentialMapOutput struct{ *pulumi.OutputState }

func (SshCredentialMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SshCredential)(nil)).Elem()
}

func (o SshCredentialMapOutput) ToSshCredentialMapOutput() SshCredentialMapOutput {
	return o
}

func (o SshCredentialMapOutput) ToSshCredentialMapOutputWithContext(ctx context.Context) SshCredentialMapOutput {
	return o
}

func (o SshCredentialMapOutput) MapIndex(k pulumi.StringInput) SshCredentialOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SshCredential {
		return vs[0].(map[string]*SshCredential)[vs[1].(string)]
	}).(SshCredentialOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SshCredentialInput)(nil)).Elem(), &SshCredential{})
	pulumi.RegisterInputType(reflect.TypeOf((*SshCredentialArrayInput)(nil)).Elem(), SshCredentialArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SshCredentialMapInput)(nil)).Elem(), SshCredentialMap{})
	pulumi.RegisterOutputType(SshCredentialOutput{})
	pulumi.RegisterOutputType(SshCredentialArrayOutput{})
	pulumi.RegisterOutputType(SshCredentialMapOutput{})
}
