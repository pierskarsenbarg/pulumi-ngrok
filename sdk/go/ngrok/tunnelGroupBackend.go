// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ngrok

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-ngrok/sdk/go/ngrok/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// A Tunnel Group Backend balances traffic among all online tunnels that match
//
//	a label selector.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-ngrok/sdk/go/ngrok"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := ngrok.NewTunnelGroupBackend(ctx, "example", &ngrok.TunnelGroupBackendArgs{
//				Description: pulumi.String("acme tunnel group"),
//				Labels: pulumi.StringMap{
//					"baz": pulumi.String("qux"),
//					"foo": pulumi.String("bar"),
//				},
//				Metadata: pulumi.String("{\"environment\": \"staging\"}"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type TunnelGroupBackend struct {
	pulumi.CustomResourceState

	// timestamp when the backend was created, RFC 3339 format
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// human-readable description of this backend. Optional
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// labels to watch for tunnels on, e.g. app->foo, dc->bar
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// arbitrary user-defined machine-readable data of this backend. Optional
	Metadata pulumi.StringPtrOutput `pulumi:"metadata"`
	// tunnels matching this backend
	Tunnels TunnelGroupBackendTunnelArrayOutput `pulumi:"tunnels"`
	// URI of the TunnelGroupBackend API resource
	Uri pulumi.StringOutput `pulumi:"uri"`
}

// NewTunnelGroupBackend registers a new resource with the given unique name, arguments, and options.
func NewTunnelGroupBackend(ctx *pulumi.Context,
	name string, args *TunnelGroupBackendArgs, opts ...pulumi.ResourceOption) (*TunnelGroupBackend, error) {
	if args == nil {
		args = &TunnelGroupBackendArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TunnelGroupBackend
	err := ctx.RegisterResource("ngrok:index/tunnelGroupBackend:TunnelGroupBackend", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTunnelGroupBackend gets an existing TunnelGroupBackend resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTunnelGroupBackend(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TunnelGroupBackendState, opts ...pulumi.ResourceOption) (*TunnelGroupBackend, error) {
	var resource TunnelGroupBackend
	err := ctx.ReadResource("ngrok:index/tunnelGroupBackend:TunnelGroupBackend", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TunnelGroupBackend resources.
type tunnelGroupBackendState struct {
	// timestamp when the backend was created, RFC 3339 format
	CreatedAt *string `pulumi:"createdAt"`
	// human-readable description of this backend. Optional
	Description *string `pulumi:"description"`
	// labels to watch for tunnels on, e.g. app->foo, dc->bar
	Labels map[string]string `pulumi:"labels"`
	// arbitrary user-defined machine-readable data of this backend. Optional
	Metadata *string `pulumi:"metadata"`
	// tunnels matching this backend
	Tunnels []TunnelGroupBackendTunnel `pulumi:"tunnels"`
	// URI of the TunnelGroupBackend API resource
	Uri *string `pulumi:"uri"`
}

type TunnelGroupBackendState struct {
	// timestamp when the backend was created, RFC 3339 format
	CreatedAt pulumi.StringPtrInput
	// human-readable description of this backend. Optional
	Description pulumi.StringPtrInput
	// labels to watch for tunnels on, e.g. app->foo, dc->bar
	Labels pulumi.StringMapInput
	// arbitrary user-defined machine-readable data of this backend. Optional
	Metadata pulumi.StringPtrInput
	// tunnels matching this backend
	Tunnels TunnelGroupBackendTunnelArrayInput
	// URI of the TunnelGroupBackend API resource
	Uri pulumi.StringPtrInput
}

func (TunnelGroupBackendState) ElementType() reflect.Type {
	return reflect.TypeOf((*tunnelGroupBackendState)(nil)).Elem()
}

type tunnelGroupBackendArgs struct {
	// timestamp when the backend was created, RFC 3339 format
	CreatedAt *string `pulumi:"createdAt"`
	// human-readable description of this backend. Optional
	Description *string `pulumi:"description"`
	// labels to watch for tunnels on, e.g. app->foo, dc->bar
	Labels map[string]string `pulumi:"labels"`
	// arbitrary user-defined machine-readable data of this backend. Optional
	Metadata *string `pulumi:"metadata"`
	// tunnels matching this backend
	Tunnels []TunnelGroupBackendTunnel `pulumi:"tunnels"`
	// URI of the TunnelGroupBackend API resource
	Uri *string `pulumi:"uri"`
}

// The set of arguments for constructing a TunnelGroupBackend resource.
type TunnelGroupBackendArgs struct {
	// timestamp when the backend was created, RFC 3339 format
	CreatedAt pulumi.StringPtrInput
	// human-readable description of this backend. Optional
	Description pulumi.StringPtrInput
	// labels to watch for tunnels on, e.g. app->foo, dc->bar
	Labels pulumi.StringMapInput
	// arbitrary user-defined machine-readable data of this backend. Optional
	Metadata pulumi.StringPtrInput
	// tunnels matching this backend
	Tunnels TunnelGroupBackendTunnelArrayInput
	// URI of the TunnelGroupBackend API resource
	Uri pulumi.StringPtrInput
}

func (TunnelGroupBackendArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*tunnelGroupBackendArgs)(nil)).Elem()
}

type TunnelGroupBackendInput interface {
	pulumi.Input

	ToTunnelGroupBackendOutput() TunnelGroupBackendOutput
	ToTunnelGroupBackendOutputWithContext(ctx context.Context) TunnelGroupBackendOutput
}

func (*TunnelGroupBackend) ElementType() reflect.Type {
	return reflect.TypeOf((**TunnelGroupBackend)(nil)).Elem()
}

func (i *TunnelGroupBackend) ToTunnelGroupBackendOutput() TunnelGroupBackendOutput {
	return i.ToTunnelGroupBackendOutputWithContext(context.Background())
}

func (i *TunnelGroupBackend) ToTunnelGroupBackendOutputWithContext(ctx context.Context) TunnelGroupBackendOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TunnelGroupBackendOutput)
}

func (i *TunnelGroupBackend) ToOutput(ctx context.Context) pulumix.Output[*TunnelGroupBackend] {
	return pulumix.Output[*TunnelGroupBackend]{
		OutputState: i.ToTunnelGroupBackendOutputWithContext(ctx).OutputState,
	}
}

// TunnelGroupBackendArrayInput is an input type that accepts TunnelGroupBackendArray and TunnelGroupBackendArrayOutput values.
// You can construct a concrete instance of `TunnelGroupBackendArrayInput` via:
//
//	TunnelGroupBackendArray{ TunnelGroupBackendArgs{...} }
type TunnelGroupBackendArrayInput interface {
	pulumi.Input

	ToTunnelGroupBackendArrayOutput() TunnelGroupBackendArrayOutput
	ToTunnelGroupBackendArrayOutputWithContext(context.Context) TunnelGroupBackendArrayOutput
}

type TunnelGroupBackendArray []TunnelGroupBackendInput

func (TunnelGroupBackendArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TunnelGroupBackend)(nil)).Elem()
}

func (i TunnelGroupBackendArray) ToTunnelGroupBackendArrayOutput() TunnelGroupBackendArrayOutput {
	return i.ToTunnelGroupBackendArrayOutputWithContext(context.Background())
}

func (i TunnelGroupBackendArray) ToTunnelGroupBackendArrayOutputWithContext(ctx context.Context) TunnelGroupBackendArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TunnelGroupBackendArrayOutput)
}

func (i TunnelGroupBackendArray) ToOutput(ctx context.Context) pulumix.Output[[]*TunnelGroupBackend] {
	return pulumix.Output[[]*TunnelGroupBackend]{
		OutputState: i.ToTunnelGroupBackendArrayOutputWithContext(ctx).OutputState,
	}
}

// TunnelGroupBackendMapInput is an input type that accepts TunnelGroupBackendMap and TunnelGroupBackendMapOutput values.
// You can construct a concrete instance of `TunnelGroupBackendMapInput` via:
//
//	TunnelGroupBackendMap{ "key": TunnelGroupBackendArgs{...} }
type TunnelGroupBackendMapInput interface {
	pulumi.Input

	ToTunnelGroupBackendMapOutput() TunnelGroupBackendMapOutput
	ToTunnelGroupBackendMapOutputWithContext(context.Context) TunnelGroupBackendMapOutput
}

type TunnelGroupBackendMap map[string]TunnelGroupBackendInput

func (TunnelGroupBackendMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TunnelGroupBackend)(nil)).Elem()
}

func (i TunnelGroupBackendMap) ToTunnelGroupBackendMapOutput() TunnelGroupBackendMapOutput {
	return i.ToTunnelGroupBackendMapOutputWithContext(context.Background())
}

func (i TunnelGroupBackendMap) ToTunnelGroupBackendMapOutputWithContext(ctx context.Context) TunnelGroupBackendMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TunnelGroupBackendMapOutput)
}

func (i TunnelGroupBackendMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*TunnelGroupBackend] {
	return pulumix.Output[map[string]*TunnelGroupBackend]{
		OutputState: i.ToTunnelGroupBackendMapOutputWithContext(ctx).OutputState,
	}
}

type TunnelGroupBackendOutput struct{ *pulumi.OutputState }

func (TunnelGroupBackendOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TunnelGroupBackend)(nil)).Elem()
}

func (o TunnelGroupBackendOutput) ToTunnelGroupBackendOutput() TunnelGroupBackendOutput {
	return o
}

func (o TunnelGroupBackendOutput) ToTunnelGroupBackendOutputWithContext(ctx context.Context) TunnelGroupBackendOutput {
	return o
}

func (o TunnelGroupBackendOutput) ToOutput(ctx context.Context) pulumix.Output[*TunnelGroupBackend] {
	return pulumix.Output[*TunnelGroupBackend]{
		OutputState: o.OutputState,
	}
}

// timestamp when the backend was created, RFC 3339 format
func (o TunnelGroupBackendOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *TunnelGroupBackend) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// human-readable description of this backend. Optional
func (o TunnelGroupBackendOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TunnelGroupBackend) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// labels to watch for tunnels on, e.g. app->foo, dc->bar
func (o TunnelGroupBackendOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *TunnelGroupBackend) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// arbitrary user-defined machine-readable data of this backend. Optional
func (o TunnelGroupBackendOutput) Metadata() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TunnelGroupBackend) pulumi.StringPtrOutput { return v.Metadata }).(pulumi.StringPtrOutput)
}

// tunnels matching this backend
func (o TunnelGroupBackendOutput) Tunnels() TunnelGroupBackendTunnelArrayOutput {
	return o.ApplyT(func(v *TunnelGroupBackend) TunnelGroupBackendTunnelArrayOutput { return v.Tunnels }).(TunnelGroupBackendTunnelArrayOutput)
}

// URI of the TunnelGroupBackend API resource
func (o TunnelGroupBackendOutput) Uri() pulumi.StringOutput {
	return o.ApplyT(func(v *TunnelGroupBackend) pulumi.StringOutput { return v.Uri }).(pulumi.StringOutput)
}

type TunnelGroupBackendArrayOutput struct{ *pulumi.OutputState }

func (TunnelGroupBackendArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TunnelGroupBackend)(nil)).Elem()
}

func (o TunnelGroupBackendArrayOutput) ToTunnelGroupBackendArrayOutput() TunnelGroupBackendArrayOutput {
	return o
}

func (o TunnelGroupBackendArrayOutput) ToTunnelGroupBackendArrayOutputWithContext(ctx context.Context) TunnelGroupBackendArrayOutput {
	return o
}

func (o TunnelGroupBackendArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*TunnelGroupBackend] {
	return pulumix.Output[[]*TunnelGroupBackend]{
		OutputState: o.OutputState,
	}
}

func (o TunnelGroupBackendArrayOutput) Index(i pulumi.IntInput) TunnelGroupBackendOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TunnelGroupBackend {
		return vs[0].([]*TunnelGroupBackend)[vs[1].(int)]
	}).(TunnelGroupBackendOutput)
}

type TunnelGroupBackendMapOutput struct{ *pulumi.OutputState }

func (TunnelGroupBackendMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TunnelGroupBackend)(nil)).Elem()
}

func (o TunnelGroupBackendMapOutput) ToTunnelGroupBackendMapOutput() TunnelGroupBackendMapOutput {
	return o
}

func (o TunnelGroupBackendMapOutput) ToTunnelGroupBackendMapOutputWithContext(ctx context.Context) TunnelGroupBackendMapOutput {
	return o
}

func (o TunnelGroupBackendMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*TunnelGroupBackend] {
	return pulumix.Output[map[string]*TunnelGroupBackend]{
		OutputState: o.OutputState,
	}
}

func (o TunnelGroupBackendMapOutput) MapIndex(k pulumi.StringInput) TunnelGroupBackendOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TunnelGroupBackend {
		return vs[0].(map[string]*TunnelGroupBackend)[vs[1].(string)]
	}).(TunnelGroupBackendOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TunnelGroupBackendInput)(nil)).Elem(), &TunnelGroupBackend{})
	pulumi.RegisterInputType(reflect.TypeOf((*TunnelGroupBackendArrayInput)(nil)).Elem(), TunnelGroupBackendArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TunnelGroupBackendMapInput)(nil)).Elem(), TunnelGroupBackendMap{})
	pulumi.RegisterOutputType(TunnelGroupBackendOutput{})
	pulumi.RegisterOutputType(TunnelGroupBackendArrayOutput{})
	pulumi.RegisterOutputType(TunnelGroupBackendMapOutput{})
}
