// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ngrok

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-ngrok/sdk/go/ngrok/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// SSH User Certificates are presented by SSH clients when connecting to an SSH
//
//	server to authenticate their connection. The SSH server must trust the SSH
//	Certificate Authority used to sign the certificate.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-ngrok/sdk/go/ngrok"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := ngrok.NewSshUserCertificate(ctx, "example", &ngrok.SshUserCertificateArgs{
//				Description: pulumi.String("temporary access to staging machine"),
//				Principals: pulumi.StringArray{
//					pulumi.String("ec2-user"),
//					pulumi.String("root"),
//				},
//				PublicKey:                 pulumi.String("ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK58lFzmWlDimDtBz78wVT4oauA8PjY0CiXTCEIsBNC6UwOJvZ0jdSaYNhDaa7dRV84DfBb/gKzqlXC7cVMZjl0= alan@work-laptop"),
//				SshCertificateAuthorityId: pulumi.String("sshca_26rOyirnW8khUZJ8xjNfPu3GPdi"),
//				ValidUntil:                pulumi.String("2022-06-22T22:21:34-05:00"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type SshUserCertificate struct {
	pulumi.CustomResourceState

	// the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshdConfig` configuration file with a `HostCertificate` directive
	Certificate pulumi.StringOutput `pulumi:"certificate"`
	// A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	CriticalOptions pulumi.StringMapOutput `pulumi:"criticalOptions"`
	// human-readable description of this SSH User Certificate. optional, max 255 bytes.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	Extensions pulumi.StringMapOutput `pulumi:"extensions"`
	// the key type of the `publicKey`, one of `rsa`, `ecdsa` or `ed25519`
	KeyType pulumi.StringOutput `pulumi:"keyType"`
	// arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
	Metadata pulumi.StringPtrOutput `pulumi:"metadata"`
	// the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
	Principals pulumi.StringArrayOutput `pulumi:"principals"`
	// a public key in OpenSSH Authorized Keys format that this certificate signs
	PublicKey pulumi.StringOutput `pulumi:"publicKey"`
	// the ssh certificate authority that is used to sign this ssh user certificate
	SshCertificateAuthorityId pulumi.StringOutput `pulumi:"sshCertificateAuthorityId"`
	// the time when the ssh host certificate becomes valid, in RFC 3339 format.
	ValidAfter pulumi.StringPtrOutput `pulumi:"validAfter"`
	// the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `validBefore`.
	ValidUntil pulumi.StringPtrOutput `pulumi:"validUntil"`
}

// NewSshUserCertificate registers a new resource with the given unique name, arguments, and options.
func NewSshUserCertificate(ctx *pulumi.Context,
	name string, args *SshUserCertificateArgs, opts ...pulumi.ResourceOption) (*SshUserCertificate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.PublicKey == nil {
		return nil, errors.New("invalid value for required argument 'PublicKey'")
	}
	if args.SshCertificateAuthorityId == nil {
		return nil, errors.New("invalid value for required argument 'SshCertificateAuthorityId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SshUserCertificate
	err := ctx.RegisterResource("ngrok:index/sshUserCertificate:SshUserCertificate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSshUserCertificate gets an existing SshUserCertificate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSshUserCertificate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SshUserCertificateState, opts ...pulumi.ResourceOption) (*SshUserCertificate, error) {
	var resource SshUserCertificate
	err := ctx.ReadResource("ngrok:index/sshUserCertificate:SshUserCertificate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SshUserCertificate resources.
type sshUserCertificateState struct {
	// the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshdConfig` configuration file with a `HostCertificate` directive
	Certificate *string `pulumi:"certificate"`
	// A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	CriticalOptions map[string]string `pulumi:"criticalOptions"`
	// human-readable description of this SSH User Certificate. optional, max 255 bytes.
	Description *string `pulumi:"description"`
	// A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	Extensions map[string]string `pulumi:"extensions"`
	// the key type of the `publicKey`, one of `rsa`, `ecdsa` or `ed25519`
	KeyType *string `pulumi:"keyType"`
	// arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
	Metadata *string `pulumi:"metadata"`
	// the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
	Principals []string `pulumi:"principals"`
	// a public key in OpenSSH Authorized Keys format that this certificate signs
	PublicKey *string `pulumi:"publicKey"`
	// the ssh certificate authority that is used to sign this ssh user certificate
	SshCertificateAuthorityId *string `pulumi:"sshCertificateAuthorityId"`
	// the time when the ssh host certificate becomes valid, in RFC 3339 format.
	ValidAfter *string `pulumi:"validAfter"`
	// the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `validBefore`.
	ValidUntil *string `pulumi:"validUntil"`
}

type SshUserCertificateState struct {
	// the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshdConfig` configuration file with a `HostCertificate` directive
	Certificate pulumi.StringPtrInput
	// A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	CriticalOptions pulumi.StringMapInput
	// human-readable description of this SSH User Certificate. optional, max 255 bytes.
	Description pulumi.StringPtrInput
	// A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	Extensions pulumi.StringMapInput
	// the key type of the `publicKey`, one of `rsa`, `ecdsa` or `ed25519`
	KeyType pulumi.StringPtrInput
	// arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
	Metadata pulumi.StringPtrInput
	// the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
	Principals pulumi.StringArrayInput
	// a public key in OpenSSH Authorized Keys format that this certificate signs
	PublicKey pulumi.StringPtrInput
	// the ssh certificate authority that is used to sign this ssh user certificate
	SshCertificateAuthorityId pulumi.StringPtrInput
	// the time when the ssh host certificate becomes valid, in RFC 3339 format.
	ValidAfter pulumi.StringPtrInput
	// the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `validBefore`.
	ValidUntil pulumi.StringPtrInput
}

func (SshUserCertificateState) ElementType() reflect.Type {
	return reflect.TypeOf((*sshUserCertificateState)(nil)).Elem()
}

type sshUserCertificateArgs struct {
	// the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshdConfig` configuration file with a `HostCertificate` directive
	Certificate *string `pulumi:"certificate"`
	// A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	CriticalOptions map[string]string `pulumi:"criticalOptions"`
	// human-readable description of this SSH User Certificate. optional, max 255 bytes.
	Description *string `pulumi:"description"`
	// A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	Extensions map[string]string `pulumi:"extensions"`
	// the key type of the `publicKey`, one of `rsa`, `ecdsa` or `ed25519`
	KeyType *string `pulumi:"keyType"`
	// arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
	Metadata *string `pulumi:"metadata"`
	// the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
	Principals []string `pulumi:"principals"`
	// a public key in OpenSSH Authorized Keys format that this certificate signs
	PublicKey string `pulumi:"publicKey"`
	// the ssh certificate authority that is used to sign this ssh user certificate
	SshCertificateAuthorityId string `pulumi:"sshCertificateAuthorityId"`
	// the time when the ssh host certificate becomes valid, in RFC 3339 format.
	ValidAfter *string `pulumi:"validAfter"`
	// the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `validBefore`.
	ValidUntil *string `pulumi:"validUntil"`
}

// The set of arguments for constructing a SshUserCertificate resource.
type SshUserCertificateArgs struct {
	// the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshdConfig` configuration file with a `HostCertificate` directive
	Certificate pulumi.StringPtrInput
	// A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	CriticalOptions pulumi.StringMapInput
	// human-readable description of this SSH User Certificate. optional, max 255 bytes.
	Description pulumi.StringPtrInput
	// A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
	Extensions pulumi.StringMapInput
	// the key type of the `publicKey`, one of `rsa`, `ecdsa` or `ed25519`
	KeyType pulumi.StringPtrInput
	// arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
	Metadata pulumi.StringPtrInput
	// the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
	Principals pulumi.StringArrayInput
	// a public key in OpenSSH Authorized Keys format that this certificate signs
	PublicKey pulumi.StringInput
	// the ssh certificate authority that is used to sign this ssh user certificate
	SshCertificateAuthorityId pulumi.StringInput
	// the time when the ssh host certificate becomes valid, in RFC 3339 format.
	ValidAfter pulumi.StringPtrInput
	// the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `validBefore`.
	ValidUntil pulumi.StringPtrInput
}

func (SshUserCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sshUserCertificateArgs)(nil)).Elem()
}

type SshUserCertificateInput interface {
	pulumi.Input

	ToSshUserCertificateOutput() SshUserCertificateOutput
	ToSshUserCertificateOutputWithContext(ctx context.Context) SshUserCertificateOutput
}

func (*SshUserCertificate) ElementType() reflect.Type {
	return reflect.TypeOf((**SshUserCertificate)(nil)).Elem()
}

func (i *SshUserCertificate) ToSshUserCertificateOutput() SshUserCertificateOutput {
	return i.ToSshUserCertificateOutputWithContext(context.Background())
}

func (i *SshUserCertificate) ToSshUserCertificateOutputWithContext(ctx context.Context) SshUserCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SshUserCertificateOutput)
}

func (i *SshUserCertificate) ToOutput(ctx context.Context) pulumix.Output[*SshUserCertificate] {
	return pulumix.Output[*SshUserCertificate]{
		OutputState: i.ToSshUserCertificateOutputWithContext(ctx).OutputState,
	}
}

// SshUserCertificateArrayInput is an input type that accepts SshUserCertificateArray and SshUserCertificateArrayOutput values.
// You can construct a concrete instance of `SshUserCertificateArrayInput` via:
//
//	SshUserCertificateArray{ SshUserCertificateArgs{...} }
type SshUserCertificateArrayInput interface {
	pulumi.Input

	ToSshUserCertificateArrayOutput() SshUserCertificateArrayOutput
	ToSshUserCertificateArrayOutputWithContext(context.Context) SshUserCertificateArrayOutput
}

type SshUserCertificateArray []SshUserCertificateInput

func (SshUserCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SshUserCertificate)(nil)).Elem()
}

func (i SshUserCertificateArray) ToSshUserCertificateArrayOutput() SshUserCertificateArrayOutput {
	return i.ToSshUserCertificateArrayOutputWithContext(context.Background())
}

func (i SshUserCertificateArray) ToSshUserCertificateArrayOutputWithContext(ctx context.Context) SshUserCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SshUserCertificateArrayOutput)
}

func (i SshUserCertificateArray) ToOutput(ctx context.Context) pulumix.Output[[]*SshUserCertificate] {
	return pulumix.Output[[]*SshUserCertificate]{
		OutputState: i.ToSshUserCertificateArrayOutputWithContext(ctx).OutputState,
	}
}

// SshUserCertificateMapInput is an input type that accepts SshUserCertificateMap and SshUserCertificateMapOutput values.
// You can construct a concrete instance of `SshUserCertificateMapInput` via:
//
//	SshUserCertificateMap{ "key": SshUserCertificateArgs{...} }
type SshUserCertificateMapInput interface {
	pulumi.Input

	ToSshUserCertificateMapOutput() SshUserCertificateMapOutput
	ToSshUserCertificateMapOutputWithContext(context.Context) SshUserCertificateMapOutput
}

type SshUserCertificateMap map[string]SshUserCertificateInput

func (SshUserCertificateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SshUserCertificate)(nil)).Elem()
}

func (i SshUserCertificateMap) ToSshUserCertificateMapOutput() SshUserCertificateMapOutput {
	return i.ToSshUserCertificateMapOutputWithContext(context.Background())
}

func (i SshUserCertificateMap) ToSshUserCertificateMapOutputWithContext(ctx context.Context) SshUserCertificateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SshUserCertificateMapOutput)
}

func (i SshUserCertificateMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*SshUserCertificate] {
	return pulumix.Output[map[string]*SshUserCertificate]{
		OutputState: i.ToSshUserCertificateMapOutputWithContext(ctx).OutputState,
	}
}

type SshUserCertificateOutput struct{ *pulumi.OutputState }

func (SshUserCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SshUserCertificate)(nil)).Elem()
}

func (o SshUserCertificateOutput) ToSshUserCertificateOutput() SshUserCertificateOutput {
	return o
}

func (o SshUserCertificateOutput) ToSshUserCertificateOutputWithContext(ctx context.Context) SshUserCertificateOutput {
	return o
}

func (o SshUserCertificateOutput) ToOutput(ctx context.Context) pulumix.Output[*SshUserCertificate] {
	return pulumix.Output[*SshUserCertificate]{
		OutputState: o.OutputState,
	}
}

// the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshdConfig` configuration file with a `HostCertificate` directive
func (o SshUserCertificateOutput) Certificate() pulumi.StringOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringOutput { return v.Certificate }).(pulumi.StringOutput)
}

// A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
func (o SshUserCertificateOutput) CriticalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringMapOutput { return v.CriticalOptions }).(pulumi.StringMapOutput)
}

// human-readable description of this SSH User Certificate. optional, max 255 bytes.
func (o SshUserCertificateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
func (o SshUserCertificateOutput) Extensions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringMapOutput { return v.Extensions }).(pulumi.StringMapOutput)
}

// the key type of the `publicKey`, one of `rsa`, `ecdsa` or `ed25519`
func (o SshUserCertificateOutput) KeyType() pulumi.StringOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringOutput { return v.KeyType }).(pulumi.StringOutput)
}

// arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
func (o SshUserCertificateOutput) Metadata() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringPtrOutput { return v.Metadata }).(pulumi.StringPtrOutput)
}

// the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
func (o SshUserCertificateOutput) Principals() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringArrayOutput { return v.Principals }).(pulumi.StringArrayOutput)
}

// a public key in OpenSSH Authorized Keys format that this certificate signs
func (o SshUserCertificateOutput) PublicKey() pulumi.StringOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringOutput { return v.PublicKey }).(pulumi.StringOutput)
}

// the ssh certificate authority that is used to sign this ssh user certificate
func (o SshUserCertificateOutput) SshCertificateAuthorityId() pulumi.StringOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringOutput { return v.SshCertificateAuthorityId }).(pulumi.StringOutput)
}

// the time when the ssh host certificate becomes valid, in RFC 3339 format.
func (o SshUserCertificateOutput) ValidAfter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringPtrOutput { return v.ValidAfter }).(pulumi.StringPtrOutput)
}

// the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `validBefore`.
func (o SshUserCertificateOutput) ValidUntil() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshUserCertificate) pulumi.StringPtrOutput { return v.ValidUntil }).(pulumi.StringPtrOutput)
}

type SshUserCertificateArrayOutput struct{ *pulumi.OutputState }

func (SshUserCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SshUserCertificate)(nil)).Elem()
}

func (o SshUserCertificateArrayOutput) ToSshUserCertificateArrayOutput() SshUserCertificateArrayOutput {
	return o
}

func (o SshUserCertificateArrayOutput) ToSshUserCertificateArrayOutputWithContext(ctx context.Context) SshUserCertificateArrayOutput {
	return o
}

func (o SshUserCertificateArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*SshUserCertificate] {
	return pulumix.Output[[]*SshUserCertificate]{
		OutputState: o.OutputState,
	}
}

func (o SshUserCertificateArrayOutput) Index(i pulumi.IntInput) SshUserCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SshUserCertificate {
		return vs[0].([]*SshUserCertificate)[vs[1].(int)]
	}).(SshUserCertificateOutput)
}

type SshUserCertificateMapOutput struct{ *pulumi.OutputState }

func (SshUserCertificateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SshUserCertificate)(nil)).Elem()
}

func (o SshUserCertificateMapOutput) ToSshUserCertificateMapOutput() SshUserCertificateMapOutput {
	return o
}

func (o SshUserCertificateMapOutput) ToSshUserCertificateMapOutputWithContext(ctx context.Context) SshUserCertificateMapOutput {
	return o
}

func (o SshUserCertificateMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*SshUserCertificate] {
	return pulumix.Output[map[string]*SshUserCertificate]{
		OutputState: o.OutputState,
	}
}

func (o SshUserCertificateMapOutput) MapIndex(k pulumi.StringInput) SshUserCertificateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SshUserCertificate {
		return vs[0].(map[string]*SshUserCertificate)[vs[1].(string)]
	}).(SshUserCertificateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SshUserCertificateInput)(nil)).Elem(), &SshUserCertificate{})
	pulumi.RegisterInputType(reflect.TypeOf((*SshUserCertificateArrayInput)(nil)).Elem(), SshUserCertificateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SshUserCertificateMapInput)(nil)).Elem(), SshUserCertificateMap{})
	pulumi.RegisterOutputType(SshUserCertificateOutput{})
	pulumi.RegisterOutputType(SshUserCertificateArrayOutput{})
	pulumi.RegisterOutputType(SshUserCertificateMapOutput{})
}
