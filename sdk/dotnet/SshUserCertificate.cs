// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace PiersKarsenbarg.Ngrok
{
    /// <summary>
    /// SSH User Certificates are presented by SSH clients when connecting to an SSH
    ///  server to authenticate their connection. The SSH server must trust the SSH
    ///  Certificate Authority used to sign the certificate.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using Ngrok = PiersKarsenbarg.Ngrok;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Ngrok.SshUserCertificate("example", new()
    ///     {
    ///         Description = "temporary access to staging machine",
    ///         Principals = new[]
    ///         {
    ///             "ec2-user",
    ///             "root",
    ///         },
    ///         PublicKey = "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK58lFzmWlDimDtBz78wVT4oauA8PjY0CiXTCEIsBNC6UwOJvZ0jdSaYNhDaa7dRV84DfBb/gKzqlXC7cVMZjl0= alan@work-laptop",
    ///         SshCertificateAuthorityId = "sshca_25auH5JtiUPW9eMiXYzujvcpkGW",
    ///         ValidUntil = "2022-05-26T08:23:47Z",
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [NgrokResourceType("ngrok:index/sshUserCertificate:SshUserCertificate")]
    public partial class SshUserCertificate : global::Pulumi.CustomResource
    {
        /// <summary>
        /// the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive
        /// </summary>
        [Output("certificate")]
        public Output<string> Certificate { get; private set; } = null!;

        /// <summary>
        /// A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
        /// </summary>
        [Output("criticalOptions")]
        public Output<ImmutableDictionary<string, string>?> CriticalOptions { get; private set; } = null!;

        /// <summary>
        /// human-readable description of this SSH User Certificate. optional, max 255 bytes.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
        /// </summary>
        [Output("extensions")]
        public Output<ImmutableDictionary<string, string>?> Extensions { get; private set; } = null!;

        /// <summary>
        /// the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`
        /// </summary>
        [Output("keyType")]
        public Output<string> KeyType { get; private set; } = null!;

        /// <summary>
        /// arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
        /// </summary>
        [Output("metadata")]
        public Output<string?> Metadata { get; private set; } = null!;

        /// <summary>
        /// the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizinig the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
        /// </summary>
        [Output("principals")]
        public Output<ImmutableArray<string>> Principals { get; private set; } = null!;

        /// <summary>
        /// a public key in OpenSSH Authorized Keys format that this certificate signs
        /// </summary>
        [Output("publicKey")]
        public Output<string> PublicKey { get; private set; } = null!;

        /// <summary>
        /// the ssh certificate authority that is used to sign this ssh user certificate
        /// </summary>
        [Output("sshCertificateAuthorityId")]
        public Output<string> SshCertificateAuthorityId { get; private set; } = null!;

        /// <summary>
        /// the time when the ssh host certificate becomes valid, in RFC 3339 format.
        /// </summary>
        [Output("validAfter")]
        public Output<string?> ValidAfter { get; private set; } = null!;

        /// <summary>
        /// the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.
        /// </summary>
        [Output("validUntil")]
        public Output<string?> ValidUntil { get; private set; } = null!;


        /// <summary>
        /// Create a SshUserCertificate resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public SshUserCertificate(string name, SshUserCertificateArgs args, CustomResourceOptions? options = null)
            : base("ngrok:index/sshUserCertificate:SshUserCertificate", name, args ?? new SshUserCertificateArgs(), MakeResourceOptions(options, ""))
        {
        }

        private SshUserCertificate(string name, Input<string> id, SshUserCertificateState? state = null, CustomResourceOptions? options = null)
            : base("ngrok:index/sshUserCertificate:SshUserCertificate", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pierskarsenbarg/pulumi-ngrok",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing SshUserCertificate resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static SshUserCertificate Get(string name, Input<string> id, SshUserCertificateState? state = null, CustomResourceOptions? options = null)
        {
            return new SshUserCertificate(name, id, state, options);
        }
    }

    public sealed class SshUserCertificateArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive
        /// </summary>
        [Input("certificate")]
        public Input<string>? Certificate { get; set; }

        [Input("criticalOptions")]
        private InputMap<string>? _criticalOptions;

        /// <summary>
        /// A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
        /// </summary>
        public InputMap<string> CriticalOptions
        {
            get => _criticalOptions ?? (_criticalOptions = new InputMap<string>());
            set => _criticalOptions = value;
        }

        /// <summary>
        /// human-readable description of this SSH User Certificate. optional, max 255 bytes.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("extensions")]
        private InputMap<string>? _extensions;

        /// <summary>
        /// A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
        /// </summary>
        public InputMap<string> Extensions
        {
            get => _extensions ?? (_extensions = new InputMap<string>());
            set => _extensions = value;
        }

        /// <summary>
        /// the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`
        /// </summary>
        [Input("keyType")]
        public Input<string>? KeyType { get; set; }

        /// <summary>
        /// arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
        /// </summary>
        [Input("metadata")]
        public Input<string>? Metadata { get; set; }

        [Input("principals")]
        private InputList<string>? _principals;

        /// <summary>
        /// the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizinig the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
        /// </summary>
        public InputList<string> Principals
        {
            get => _principals ?? (_principals = new InputList<string>());
            set => _principals = value;
        }

        /// <summary>
        /// a public key in OpenSSH Authorized Keys format that this certificate signs
        /// </summary>
        [Input("publicKey", required: true)]
        public Input<string> PublicKey { get; set; } = null!;

        /// <summary>
        /// the ssh certificate authority that is used to sign this ssh user certificate
        /// </summary>
        [Input("sshCertificateAuthorityId", required: true)]
        public Input<string> SshCertificateAuthorityId { get; set; } = null!;

        /// <summary>
        /// the time when the ssh host certificate becomes valid, in RFC 3339 format.
        /// </summary>
        [Input("validAfter")]
        public Input<string>? ValidAfter { get; set; }

        /// <summary>
        /// the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.
        /// </summary>
        [Input("validUntil")]
        public Input<string>? ValidUntil { get; set; }

        public SshUserCertificateArgs()
        {
        }
        public static new SshUserCertificateArgs Empty => new SshUserCertificateArgs();
    }

    public sealed class SshUserCertificateState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive
        /// </summary>
        [Input("certificate")]
        public Input<string>? Certificate { get; set; }

        [Input("criticalOptions")]
        private InputMap<string>? _criticalOptions;

        /// <summary>
        /// A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
        /// </summary>
        public InputMap<string> CriticalOptions
        {
            get => _criticalOptions ?? (_criticalOptions = new InputMap<string>());
            set => _criticalOptions = value;
        }

        /// <summary>
        /// human-readable description of this SSH User Certificate. optional, max 255 bytes.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("extensions")]
        private InputMap<string>? _extensions;

        /// <summary>
        /// A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
        /// </summary>
        public InputMap<string> Extensions
        {
            get => _extensions ?? (_extensions = new InputMap<string>());
            set => _extensions = value;
        }

        /// <summary>
        /// the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`
        /// </summary>
        [Input("keyType")]
        public Input<string>? KeyType { get; set; }

        /// <summary>
        /// arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
        /// </summary>
        [Input("metadata")]
        public Input<string>? Metadata { get; set; }

        [Input("principals")]
        private InputList<string>? _principals;

        /// <summary>
        /// the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizinig the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
        /// </summary>
        public InputList<string> Principals
        {
            get => _principals ?? (_principals = new InputList<string>());
            set => _principals = value;
        }

        /// <summary>
        /// a public key in OpenSSH Authorized Keys format that this certificate signs
        /// </summary>
        [Input("publicKey")]
        public Input<string>? PublicKey { get; set; }

        /// <summary>
        /// the ssh certificate authority that is used to sign this ssh user certificate
        /// </summary>
        [Input("sshCertificateAuthorityId")]
        public Input<string>? SshCertificateAuthorityId { get; set; }

        /// <summary>
        /// the time when the ssh host certificate becomes valid, in RFC 3339 format.
        /// </summary>
        [Input("validAfter")]
        public Input<string>? ValidAfter { get; set; }

        /// <summary>
        /// the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.
        /// </summary>
        [Input("validUntil")]
        public Input<string>? ValidUntil { get; set; }

        public SshUserCertificateState()
        {
        }
        public static new SshUserCertificateState Empty => new SshUserCertificateState();
    }
}
