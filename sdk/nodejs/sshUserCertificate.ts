// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * SSH User Certificates are presented by SSH clients when connecting to an SSH
 *  server to authenticate their connection. The SSH server must trust the SSH
 *  Certificate Authority used to sign the certificate.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as ngrok from "@pierskarsenbarg/ngrok";
 *
 * const example = new ngrok.SshUserCertificate("example", {
 *     description: "temporary access to staging machine",
 *     principals: [
 *         "ec2-user",
 *         "root",
 *     ],
 *     publicKey: "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK58lFzmWlDimDtBz78wVT4oauA8PjY0CiXTCEIsBNC6UwOJvZ0jdSaYNhDaa7dRV84DfBb/gKzqlXC7cVMZjl0= alan@work-laptop",
 *     sshCertificateAuthorityId: "sshca_25auH5JtiUPW9eMiXYzujvcpkGW",
 *     validUntil: "2022-05-26T08:23:47Z",
 * });
 * ```
 */
export class SshUserCertificate extends pulumi.CustomResource {
    /**
     * Get an existing SshUserCertificate resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: SshUserCertificateState, opts?: pulumi.CustomResourceOptions): SshUserCertificate {
        return new SshUserCertificate(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'ngrok:index/sshUserCertificate:SshUserCertificate';

    /**
     * Returns true if the given object is an instance of SshUserCertificate.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is SshUserCertificate {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === SshUserCertificate.__pulumiType;
    }

    /**
     * the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshdConfig` configuration file with a `HostCertificate` directive
     */
    public readonly certificate!: pulumi.Output<string>;
    /**
     * A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
     */
    public readonly criticalOptions!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * human-readable description of this SSH User Certificate. optional, max 255 bytes.
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
     */
    public readonly extensions!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * the key type of the `publicKey`, one of `rsa`, `ecdsa` or `ed25519`
     */
    public readonly keyType!: pulumi.Output<string>;
    /**
     * arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
     */
    public readonly metadata!: pulumi.Output<string | undefined>;
    /**
     * the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizinig the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
     */
    public readonly principals!: pulumi.Output<string[] | undefined>;
    /**
     * a public key in OpenSSH Authorized Keys format that this certificate signs
     */
    public readonly publicKey!: pulumi.Output<string>;
    /**
     * the ssh certificate authority that is used to sign this ssh user certificate
     */
    public readonly sshCertificateAuthorityId!: pulumi.Output<string>;
    /**
     * the time when the ssh host certificate becomes valid, in RFC 3339 format.
     */
    public readonly validAfter!: pulumi.Output<string | undefined>;
    /**
     * the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `validBefore`.
     */
    public readonly validUntil!: pulumi.Output<string | undefined>;

    /**
     * Create a SshUserCertificate resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: SshUserCertificateArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: SshUserCertificateArgs | SshUserCertificateState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as SshUserCertificateState | undefined;
            resourceInputs["certificate"] = state ? state.certificate : undefined;
            resourceInputs["criticalOptions"] = state ? state.criticalOptions : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["extensions"] = state ? state.extensions : undefined;
            resourceInputs["keyType"] = state ? state.keyType : undefined;
            resourceInputs["metadata"] = state ? state.metadata : undefined;
            resourceInputs["principals"] = state ? state.principals : undefined;
            resourceInputs["publicKey"] = state ? state.publicKey : undefined;
            resourceInputs["sshCertificateAuthorityId"] = state ? state.sshCertificateAuthorityId : undefined;
            resourceInputs["validAfter"] = state ? state.validAfter : undefined;
            resourceInputs["validUntil"] = state ? state.validUntil : undefined;
        } else {
            const args = argsOrState as SshUserCertificateArgs | undefined;
            if ((!args || args.publicKey === undefined) && !opts.urn) {
                throw new Error("Missing required property 'publicKey'");
            }
            if ((!args || args.sshCertificateAuthorityId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'sshCertificateAuthorityId'");
            }
            resourceInputs["certificate"] = args ? args.certificate : undefined;
            resourceInputs["criticalOptions"] = args ? args.criticalOptions : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["extensions"] = args ? args.extensions : undefined;
            resourceInputs["keyType"] = args ? args.keyType : undefined;
            resourceInputs["metadata"] = args ? args.metadata : undefined;
            resourceInputs["principals"] = args ? args.principals : undefined;
            resourceInputs["publicKey"] = args ? args.publicKey : undefined;
            resourceInputs["sshCertificateAuthorityId"] = args ? args.sshCertificateAuthorityId : undefined;
            resourceInputs["validAfter"] = args ? args.validAfter : undefined;
            resourceInputs["validUntil"] = args ? args.validUntil : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(SshUserCertificate.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering SshUserCertificate resources.
 */
export interface SshUserCertificateState {
    /**
     * the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshdConfig` configuration file with a `HostCertificate` directive
     */
    certificate?: pulumi.Input<string>;
    /**
     * A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
     */
    criticalOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * human-readable description of this SSH User Certificate. optional, max 255 bytes.
     */
    description?: pulumi.Input<string>;
    /**
     * A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
     */
    extensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * the key type of the `publicKey`, one of `rsa`, `ecdsa` or `ed25519`
     */
    keyType?: pulumi.Input<string>;
    /**
     * arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
     */
    metadata?: pulumi.Input<string>;
    /**
     * the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizinig the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
     */
    principals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * a public key in OpenSSH Authorized Keys format that this certificate signs
     */
    publicKey?: pulumi.Input<string>;
    /**
     * the ssh certificate authority that is used to sign this ssh user certificate
     */
    sshCertificateAuthorityId?: pulumi.Input<string>;
    /**
     * the time when the ssh host certificate becomes valid, in RFC 3339 format.
     */
    validAfter?: pulumi.Input<string>;
    /**
     * the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `validBefore`.
     */
    validUntil?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a SshUserCertificate resource.
 */
export interface SshUserCertificateArgs {
    /**
     * the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshdConfig` configuration file with a `HostCertificate` directive
     */
    certificate?: pulumi.Input<string>;
    /**
     * A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
     */
    criticalOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * human-readable description of this SSH User Certificate. optional, max 255 bytes.
     */
    description?: pulumi.Input<string>;
    /**
     * A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{"permit-pty": "", "permit-user-rc": ""}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.
     */
    extensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * the key type of the `publicKey`, one of `rsa`, `ecdsa` or `ed25519`
     */
    keyType?: pulumi.Input<string>;
    /**
     * arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.
     */
    metadata?: pulumi.Input<string>;
    /**
     * the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizinig the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.
     */
    principals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * a public key in OpenSSH Authorized Keys format that this certificate signs
     */
    publicKey: pulumi.Input<string>;
    /**
     * the ssh certificate authority that is used to sign this ssh user certificate
     */
    sshCertificateAuthorityId: pulumi.Input<string>;
    /**
     * the time when the ssh host certificate becomes valid, in RFC 3339 format.
     */
    validAfter?: pulumi.Input<string>;
    /**
     * the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `validBefore`.
     */
    validUntil?: pulumi.Input<string>;
}
