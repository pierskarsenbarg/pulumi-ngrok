{
    "name": "ngrok",
    "displayName": "ngrok",
    "description": "A Pulumi package for creating and managing ngrok cloud resources.",
    "keywords": [
        "pulumi",
        "ngrok",
        "category/cloud"
    ],
    "homepage": "https://ngrok.com",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`ngrok` Terraform Provider](https://github.com/ngrok/terraform-provider-ngrok).",
    "repository": "https://github.com/pierskarsenbarg/pulumi-ngrok",
    "logoUrl": "https://raw.githubusercontent.com/pierskarsenbarg/pulumi-ngrok/main/docs/ngrok-black.svg",
    "pluginDownloadURL": "github://api.github.com/pierskarsenbarg/pulumi-ngrok",
    "publisher": "Piers Karsenbarg",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": null,
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "rootNamespace": "PiersKarsenbarg"
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-ngrok/sdk/go/ngrok"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing ngrok cloud resources.",
            "packageName": "@pierskarsenbarg/ngrok",
            "pluginName": "",
            "pluginVersion": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/ngrok/terraform-provider-ngrok)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-ngrok` repo](https://github.com/pierskarsenbarg/pulumi-ngrok/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-ngrok` repo](https://github.com/ngrok/terraform-provider-ngrok/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "packageName": "pierskarsenbarg_pulumi_ngrok",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/ngrok/terraform-provider-ngrok)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-ngrok` repo](https://github.com/pierskarsenbarg/pulumi-ngrok/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-ngrok` repo](https://github.com/ngrok/terraform-provider-ngrok/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "apiBaseUrl": {
                "type": "string",
                "description": "base URL for the ngrok API. only overridden for ngrok's internal testing purposes.\n"
            },
            "apiKey": {
                "type": "string",
                "description": "ngrok API key used for authenticating to the API\n"
            }
        },
        "defaults": [
            "apiKey"
        ]
    },
    "types": {
        "ngrok:index/EndpointConfigurationBackend:EndpointConfigurationBackend": {
            "properties": {
                "backends": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationBackendBackend:EndpointConfigurationBackendBackend"
                    },
                    "description": "backend to be used to back this endpoint\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationBackendBackend:EndpointConfigurationBackendBackend": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "unique identifier of this endpoint configuration\n"
                },
                "uri": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "uri"
                    ]
                }
            }
        },
        "ngrok:index/EndpointConfigurationBasicAuth:EndpointConfigurationBasicAuth": {
            "properties": {
                "allowOptions": {
                    "type": "boolean",
                    "description": "true or false indicating whether to allow OPTIONS requests through without authentication which is necessary for CORS. default is `false`\n"
                },
                "authProviderId": {
                    "type": "string",
                    "description": "determines how the basic auth credentials are validated. Currently only the value `agent` is supported which means that credentials will be validated against the username and password specified by the ngrok agent's `--basic-auth` flag, if any.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "realm": {
                    "type": "string",
                    "description": "an arbitrary string to be specified in as the 'realm' value in the `WWW-Authenticate` header. default is `ngrok`\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationCircuitBreaker:EndpointConfigurationCircuitBreaker": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "errorThresholdPercentage": {
                    "type": "number",
                    "description": "Error threshold percentage should be between 0 - 1.0, not 0-100.0\n"
                },
                "numBuckets": {
                    "type": "integer",
                    "description": "Integer number of buckets into which metrics are retained. Max 128.\n"
                },
                "rollingWindow": {
                    "type": "integer",
                    "description": "Integer number of seconds in the statistical rolling window that metrics are retained for.\n"
                },
                "trippedDuration": {
                    "type": "integer",
                    "description": "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health\n"
                },
                "volumeThreshold": {
                    "type": "integer",
                    "description": "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationCompression:EndpointConfigurationCompression": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationIpPolicy:EndpointConfigurationIpPolicy": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "ipPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationIpPolicyIpPolicy:EndpointConfigurationIpPolicyIpPolicy"
                    },
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ipPolicies"
                    ]
                }
            }
        },
        "ngrok:index/EndpointConfigurationIpPolicyIpPolicy:EndpointConfigurationIpPolicyIpPolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "unique identifier of this endpoint configuration\n"
                },
                "uri": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "uri"
                    ]
                }
            }
        },
        "ngrok:index/EndpointConfigurationLogging:EndpointConfigurationLogging": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "eventStreams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationLoggingEventStream:EndpointConfigurationLoggingEventStream"
                    },
                    "description": "list of all EventStreams that will be used to configure and export this endpoint's logs\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "eventStreams"
                    ]
                }
            }
        },
        "ngrok:index/EndpointConfigurationLoggingEventStream:EndpointConfigurationLoggingEventStream": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "unique identifier of this endpoint configuration\n"
                },
                "uri": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "uri"
                    ]
                }
            }
        },
        "ngrok:index/EndpointConfigurationMutualTl:EndpointConfigurationMutualTl": {
            "properties": {
                "certificateAuthorities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationMutualTlCertificateAuthority:EndpointConfigurationMutualTlCertificateAuthority"
                    },
                    "description": "PEM-encoded CA certificates that will be used to validate. Multiple CAs may be provided by concatenating them together.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "certificateAuthorities"
                    ]
                }
            }
        },
        "ngrok:index/EndpointConfigurationMutualTlCertificateAuthority:EndpointConfigurationMutualTlCertificateAuthority": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "unique identifier of this endpoint configuration\n"
                },
                "uri": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "uri"
                    ]
                }
            }
        },
        "ngrok:index/EndpointConfigurationOauth:EndpointConfigurationOauth": {
            "properties": {
                "authCheckInterval": {
                    "type": "integer",
                    "description": "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.\n"
                },
                "cookiePrefix": {
                    "type": "string",
                    "description": "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "inactivityTimeout": {
                    "type": "integer",
                    "description": "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.\n"
                },
                "maximumDuration": {
                    "type": "integer",
                    "description": "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.\n"
                },
                "optionsPassthrough": {
                    "type": "boolean",
                    "description": "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.\n"
                },
                "providers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationOauthProvider:EndpointConfigurationOauthProvider"
                    },
                    "description": "an object which defines the identity provider to use for authentication and configuration for who may access the endpoint\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationOauthProvider:EndpointConfigurationOauthProvider": {
            "properties": {
                "facebooks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationOauthProviderFacebook:EndpointConfigurationOauthProviderFacebook"
                    }
                },
                "githubs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationOauthProviderGithub:EndpointConfigurationOauthProviderGithub"
                    }
                },
                "googles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationOauthProviderGoogle:EndpointConfigurationOauthProviderGoogle"
                    }
                },
                "microsofts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationOauthProviderMicrosoft:EndpointConfigurationOauthProviderMicrosoft"
                    }
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationOauthProviderFacebook:EndpointConfigurationOauthProviderFacebook": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string",
                    "secret": true
                },
                "emailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationOauthProviderGithub:EndpointConfigurationOauthProviderGithub": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string",
                    "secret": true
                },
                "emailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationOauthProviderGoogle:EndpointConfigurationOauthProviderGoogle": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string",
                    "secret": true
                },
                "emailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationOauthProviderMicrosoft:EndpointConfigurationOauthProviderMicrosoft": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string",
                    "secret": true
                },
                "emailAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "emailDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationOidc:EndpointConfigurationOidc": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The OIDC app's client ID and OIDC audience.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The OIDC app's client secret.\n",
                    "secret": true
                },
                "cookiePrefix": {
                    "type": "string",
                    "description": "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "inactivityTimeout": {
                    "type": "integer",
                    "description": "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.\n"
                },
                "maximumDuration": {
                    "type": "integer",
                    "description": "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.\n"
                },
                "optionsPassthrough": {
                    "type": "boolean",
                    "description": "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The set of scopes to request from the OIDC identity provider.\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationRequestHeader:EndpointConfigurationRequestHeader": {
            "properties": {
                "add": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "removes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationResponseHeader:EndpointConfigurationResponseHeader": {
            "properties": {
                "add": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "removes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "a list of header names that will be removed from the HTTP Response returned to the HTTP client\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationSaml:EndpointConfigurationSaml": {
            "properties": {
                "allowIdpInitiated": {
                    "type": "boolean",
                    "description": "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.\n"
                },
                "assertionConsumerServiceUrl": {
                    "type": "string",
                    "description": "The public URL of the SP's Assertion Consumer Service. This is where the IdP will redirect to during an authentication flow. This will need to be specified to the IdP as configuration.\n",
                    "willReplaceOnChanges": true
                },
                "authorizedGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "If present, only users who are a member of one of the listed groups may access the target endpoint.\n"
                },
                "cookiePrefix": {
                    "type": "string",
                    "description": "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "entityId": {
                    "type": "string",
                    "description": "The SP Entity's unique ID. This always takes the form of a URL. In ngrok's implementation, this URL is the same as the metadata URL. This will need to be specified to the IdP as configuration.\n",
                    "willReplaceOnChanges": true
                },
                "forceAuthn": {
                    "type": "boolean",
                    "description": "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.\n"
                },
                "idpMetadata": {
                    "type": "string",
                    "description": "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.\n"
                },
                "idpMetadataUrl": {
                    "type": "string",
                    "description": "The IdP's metadata URL which returns the XML IdP EntityDescriptor. The IdP's metadata URL specifies how to connect to the IdP as well as its public key which is then used to validate the signature on incoming SAML assertions to the ACS endpoint.\n"
                },
                "inactivityTimeout": {
                    "type": "integer",
                    "description": "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.\n"
                },
                "maximumDuration": {
                    "type": "integer",
                    "description": "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.\n"
                },
                "metadataUrl": {
                    "type": "string",
                    "description": "A public URL where the SP's metadata is hosted. If an IdP supports dynamic configuration, this is the URL it can use to retrieve the SP metadata.\n",
                    "willReplaceOnChanges": true
                },
                "nameidFormat": {
                    "type": "string",
                    "description": "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.\n"
                },
                "optionsPassthrough": {
                    "type": "boolean",
                    "description": "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.\n"
                },
                "requestSigningCertificatePem": {
                    "type": "string",
                    "description": "PEM-encoded x.509 certificate of the key pair that is used to sign all SAML requests that the ngrok SP makes to the IdP. Many IdPs do not support request signing verification, but we highly recommend specifying this in the IdP's configuration if it is supported.\n",
                    "willReplaceOnChanges": true
                },
                "singleLogoutUrl": {
                    "type": "string",
                    "description": "The public URL of the SP's Single Logout Service. This is where the IdP will redirect to during a single logout flow. This will optionally need to be specified to the IdP as configuration.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "assertionConsumerServiceUrl",
                        "entityId",
                        "metadataUrl",
                        "requestSigningCertificatePem",
                        "singleLogoutUrl"
                    ]
                }
            }
        },
        "ngrok:index/EndpointConfigurationTlsTermination:EndpointConfigurationTlsTermination": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "minVersion": {
                    "type": "string",
                    "description": "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.\n"
                },
                "terminateAt": {
                    "type": "string",
                    "description": "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EndpointConfigurationWebhookValidation:EndpointConfigurationWebhookValidation": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified\n"
                },
                "provider": {
                    "type": "string",
                    "description": "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers: `SLACK`, `SNS`, `STRIPE`, `GITHUB`, `TWILIO`, `SHOPIFY`, `GITLAB`, `INTERCOM`, `SENDGRID`, `XERO`, `PAGERDUTY`.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret\n",
                    "secret": true
                }
            },
            "type": "object"
        },
        "ngrok:index/EventDestinationTarget:EventDestinationTarget": {
            "properties": {
                "cloudwatchLogs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetCloudwatchLog:EventDestinationTargetCloudwatchLog"
                    },
                    "description": "Configuration used to send events to Amazon CloudWatch Logs.\n"
                },
                "debugs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetDebug:EventDestinationTargetDebug"
                    },
                    "description": "Configuration used for internal debugging.\n"
                },
                "firehoses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetFirehose:EventDestinationTargetFirehose"
                    },
                    "description": "Configuration used to send events to Amazon Kinesis Data Firehose.\n"
                },
                "kineses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetKinese:EventDestinationTargetKinese"
                    },
                    "description": "Configuration used to send events to Amazon Kinesis.\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/EventDestinationTargetCloudwatchLog:EventDestinationTargetCloudwatchLog": {
            "properties": {
                "auths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetCloudwatchLogAuth:EventDestinationTargetCloudwatchLogAuth"
                    }
                },
                "logGroupArn": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ngrok:index/EventDestinationTargetCloudwatchLogAuth:EventDestinationTargetCloudwatchLogAuth": {
            "properties": {
                "creds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetCloudwatchLogAuthCred:EventDestinationTargetCloudwatchLogAuthCred"
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetCloudwatchLogAuthRole:EventDestinationTargetCloudwatchLogAuthRole"
                    }
                }
            },
            "type": "object"
        },
        "ngrok:index/EventDestinationTargetCloudwatchLogAuthCred:EventDestinationTargetCloudwatchLogAuthCred": {
            "properties": {
                "awsAccessKeyId": {
                    "type": "string"
                },
                "awsSecretAccessKey": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "awsAccessKeyId",
                "awsSecretAccessKey"
            ]
        },
        "ngrok:index/EventDestinationTargetCloudwatchLogAuthRole:EventDestinationTargetCloudwatchLogAuthRole": {
            "properties": {
                "roleArn": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "roleArn"
            ]
        },
        "ngrok:index/EventDestinationTargetDebug:EventDestinationTargetDebug": {
            "properties": {
                "callbackUrl": {
                    "type": "string"
                },
                "log": {
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "ngrok:index/EventDestinationTargetFirehose:EventDestinationTargetFirehose": {
            "properties": {
                "auths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetFirehoseAuth:EventDestinationTargetFirehoseAuth"
                    }
                },
                "deliveryStreamArn": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ngrok:index/EventDestinationTargetFirehoseAuth:EventDestinationTargetFirehoseAuth": {
            "properties": {
                "creds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetFirehoseAuthCred:EventDestinationTargetFirehoseAuthCred"
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetFirehoseAuthRole:EventDestinationTargetFirehoseAuthRole"
                    }
                }
            },
            "type": "object"
        },
        "ngrok:index/EventDestinationTargetFirehoseAuthCred:EventDestinationTargetFirehoseAuthCred": {
            "properties": {
                "awsAccessKeyId": {
                    "type": "string"
                },
                "awsSecretAccessKey": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "awsAccessKeyId",
                "awsSecretAccessKey"
            ]
        },
        "ngrok:index/EventDestinationTargetFirehoseAuthRole:EventDestinationTargetFirehoseAuthRole": {
            "properties": {
                "roleArn": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "roleArn"
            ]
        },
        "ngrok:index/EventDestinationTargetKinese:EventDestinationTargetKinese": {
            "properties": {
                "auths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetKineseAuth:EventDestinationTargetKineseAuth"
                    }
                },
                "streamArn": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ngrok:index/EventDestinationTargetKineseAuth:EventDestinationTargetKineseAuth": {
            "properties": {
                "creds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetKineseAuthCred:EventDestinationTargetKineseAuthCred"
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTargetKineseAuthRole:EventDestinationTargetKineseAuthRole"
                    }
                }
            },
            "type": "object"
        },
        "ngrok:index/EventDestinationTargetKineseAuthCred:EventDestinationTargetKineseAuthCred": {
            "properties": {
                "awsAccessKeyId": {
                    "type": "string"
                },
                "awsSecretAccessKey": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "awsAccessKeyId",
                "awsSecretAccessKey"
            ]
        },
        "ngrok:index/EventDestinationTargetKineseAuthRole:EventDestinationTargetKineseAuthRole": {
            "properties": {
                "roleArn": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "roleArn"
            ]
        },
        "ngrok:index/EventSubscriptionSource:EventSubscriptionSource": {
            "properties": {
                "fields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "TODO\n"
                },
                "filter": {
                    "type": "string",
                    "description": "TODO\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of event for which an event subscription will trigger\n"
                },
                "uri": {
                    "type": "string",
                    "description": "URI of the Event Source API resource.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "uri"
                    ]
                }
            }
        },
        "ngrok:index/ReservedDomainCertificateManagementPolicy:ReservedDomainCertificateManagementPolicy": {
            "properties": {
                "authority": {
                    "type": "string",
                    "description": "certificate authority to request certificates from. The only supported value is letsencrypt.\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.\n"
                }
            },
            "type": "object"
        },
        "ngrok:index/TlsCertificateSubjectAlternativeName:TlsCertificateSubjectAlternativeName": {
            "properties": {
                "dnsNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "set of additional domains (including wildcards) this TLS certificate is valid for\n",
                    "willReplaceOnChanges": true
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "set of IP addresses this TLS certificate is also valid for\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dnsNames",
                        "ips"
                    ]
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the ngrok package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "apiBaseUrl": {
                "type": "string",
                "description": "base URL for the ngrok API. only overridden for ngrok's internal testing purposes.\n"
            },
            "apiKey": {
                "type": "string",
                "description": "ngrok API key used for authenticating to the API\n"
            }
        },
        "required": [
            "apiKey"
        ],
        "inputProperties": {
            "apiBaseUrl": {
                "type": "string",
                "description": "base URL for the ngrok API. only overridden for ngrok's internal testing purposes.\n"
            },
            "apiKey": {
                "type": "string",
                "description": "ngrok API key used for authenticating to the API\n"
            }
        },
        "requiredInputs": [
            "apiKey"
        ]
    },
    "resources": {
        "ngrok:index/agentIngress:AgentIngress": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/agentIngress.AgentIngress(\"example\", {\n    description: \"acme devices\",\n    domain: \"connect.acme.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.agent_ingress.AgentIngress(\"example\",\n    description=acme devices,\n    domain=connect.acme.com)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.AgentIngress.AgentIngress(\"example\", new()\n    {\n        Description = \"acme devices\",\n        Domain = \"connect.acme.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewAgentIngress(ctx, \"example\", \u0026ngrok.AgentIngressArgs{\n\t\t\tDescription: \"acme devices\",\n\t\t\tDomain:      \"connect.acme.com\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.AgentIngress;\nimport com.pulumi.ngrok.AgentIngressArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AgentIngress(\"example\", AgentIngressArgs.builder()        \n            .description(\"acme devices\")\n            .domain(\"connect.acme.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:AgentIngress\n    properties:\n      description: acme devices\n      domain: connect.acme.com\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "timestamp when the Agent Ingress was created, RFC 3339 format\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of the use of this Agent Ingress. optional, max 255 bytes.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "the domain that you own to be used as the base domain name to generate regional agent ingress domains.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this Agent Ingress. optional, max 4096 bytes\n"
                },
                "nsTargets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "a list of target values to use as the values of NS records for the domain property these values will delegate control over the domain to ngrok\n"
                },
                "regionDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "a list of regional agent ingress domains that are subdomains of the value of domain this value may increase over time as ngrok adds more regions\n"
                },
                "uri": {
                    "type": "string",
                    "description": "URI to the API resource of this Agent ingress\n"
                }
            },
            "required": [
                "createdAt",
                "domain",
                "nsTargets",
                "regionDomains",
                "uri"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "human-readable description of the use of this Agent Ingress. optional, max 255 bytes.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "the domain that you own to be used as the base domain name to generate regional agent ingress domains.\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this Agent Ingress. optional, max 4096 bytes\n"
                },
                "uri": {
                    "type": "string",
                    "description": "URI to the API resource of this Agent ingress\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AgentIngress resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "timestamp when the Agent Ingress was created, RFC 3339 format\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of the use of this Agent Ingress. optional, max 255 bytes.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "the domain that you own to be used as the base domain name to generate regional agent ingress domains.\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this Agent Ingress. optional, max 4096 bytes\n"
                    },
                    "nsTargets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "a list of target values to use as the values of NS records for the domain property these values will delegate control over the domain to ngrok\n",
                        "willReplaceOnChanges": true
                    },
                    "regionDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "a list of regional agent ingress domains that are subdomains of the value of domain this value may increase over time as ngrok adds more regions\n",
                        "willReplaceOnChanges": true
                    },
                    "uri": {
                        "type": "string",
                        "description": "URI to the API resource of this Agent ingress\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/apiKey:ApiKey": {
            "description": "API Keys are used to authenticate to the [ngrok\n API](https://ngrok.com/docs/api#authentication). You may use the API itself\n to provision and manage API Keys but you'll need to provision your first API\n key from the [API Keys page](https://dashboard.ngrok.com/api/keys) on your\n ngrok.com dashboard.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/apiKey.ApiKey(\"example\", {\n    description: \"ad-hoc dev testing\",\n    metadata: \"{\\\"environment\\\":\\\"dev\\\"}\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.api_key.ApiKey(\"example\",\n    description=ad-hoc dev testing,\n    metadata={\"environment\":\"dev\"})\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.ApiKey.ApiKey(\"example\", new()\n    {\n        Description = \"ad-hoc dev testing\",\n        Metadata = \"{\\\"environment\\\":\\\"dev\\\"}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewApiKey(ctx, \"example\", \u0026ngrok.ApiKeyArgs{\n\t\t\tDescription: \"ad-hoc dev testing\",\n\t\t\tMetadata:    \"{\\\"environment\\\":\\\"dev\\\"}\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.ApiKey;\nimport com.pulumi.ngrok.ApiKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ApiKey(\"example\", ApiKeyArgs.builder()        \n            .description(\"ad-hoc dev testing\")\n            .metadata(\"{\\\"environment\\\":\\\"dev\\\"}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:ApiKey\n    properties:\n      description: ad-hoc dev testing\n      metadata: '{\"environment\":\"dev\"}'\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "human-readable description of what uses the API key to authenticate. optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined data of this API key. optional, max 4096 bytes\n"
                },
                "token": {
                    "type": "string",
                    "description": "the bearer token that can be placed into the Authorization header to authenticate request to the ngrok API. **This value is only available one time, on the API response from key creation. Otherwise it is null.**\n",
                    "secret": true
                }
            },
            "required": [
                "token"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "human-readable description of what uses the API key to authenticate. optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined data of this API key. optional, max 4096 bytes\n"
                },
                "token": {
                    "type": "string",
                    "description": "the bearer token that can be placed into the Authorization header to authenticate request to the ngrok API. **This value is only available one time, on the API response from key creation. Otherwise it is null.**\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiKey resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "human-readable description of what uses the API key to authenticate. optional, max 255 bytes.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined data of this API key. optional, max 4096 bytes\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "the bearer token that can be placed into the Authorization header to authenticate request to the ngrok API. **This value is only available one time, on the API response from key creation. Otherwise it is null.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/certificateAuthority:CertificateAuthority": {
            "description": "Certificate Authorities are x509 certificates that are used to sign other\n x509 certificates. Attach a Certificate Authority to the Mutual TLS module\n to verify that the TLS certificate presented by a client has been signed by\n this CA. Certificate Authorities  are used only for mTLS validation only and\n thus a private key is not included in the resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/certificateAuthority.CertificateAuthority(\"example\", {\n    caPem: `-----BEGIN CERTIFICATE-----\nMIIEETCCAvmgAwIBAgIUU3N6lNzPqar4400cLQMcVHFl+mEwDQYJKoZIhvcNAQEL\nBQAwgZcxCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5l\neTEZMBcGA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQg\nU2VydmljZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9w\nYmVhci5leGFtcGxlMB4XDTIwMDUwMTE2Mjc1OVoXDTIxMDUwMTE2Mjc1OVowgZcx\nCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5leTEZMBcG\nA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQgU2Vydmlj\nZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9wYmVhci5l\neGFtcGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7y/EAN0yZkA0\nnRpMBfomnnS8KMWHb90kvGfhkCDR8WCQz5mX7eDEYDthRQrEgp63qtJ7IoCM5f0A\nUD6J2m/mZecP7SfA8OuTAZ7UyRixpZh0zJQSgj24Sh1LQuYci0DNXrei+R1qBvd+\npmpZwkKygNrbZYe3oY1PZ3jEYPSAQzIObDF7LhdhLLrcfWa9BHOGMLnALNMY558b\nvoijTCEmRrSavdvrAS9LDRipEXT8EQOWZZT9VbPtgSBalvStdoupAptmPIWjXftf\nWi1kry+P0xVFZG9iZwUeAT6fSJ+gJD8M1UXWaQbocYrctESP0sZEFM3rzdWqrZb7\n3cH3K5OCvwIDAQABo1MwUTAdBgNVHQ4EFgQUsZdchgUimRHLiPRWw51+DGBmlfMw\nHwYDVR0jBBgwFoAUsZdchgUimRHLiPRWw51+DGBmlfMwDwYDVR0TAQH/BAUwAwEB\n/zANBgkqhkiG9w0BAQsFAAOCAQEANk25tt8sSfn6Qu1bbhWRbjKgS5z+j9LqyCna\nv3fbSchMthaQR7w0vL69ayroeYdqDZkRMmHjuYKY4NyqyXkkaqVO63wEicCo55d9\npIKuPzc/7xwdRephosjGTQ4QaQ4OnrdpJZieI92m9ODexgsab84AYmwNpbGOI/tK\nnPsQr8x1RfLs2gbBwQ4MYVM3tQQbX0o+yve5nz/NCOq4vdG+eKON5u6VYMkOOg9F\nVyNY1iISQkpNk/AF6Vi9BGuDb5Hg0phEl1Q0ntCO7ZHAUHjy0ucqXZiXoXdXZcs3\n3zKKLUKva59EDBZ5TUucvXh8VemBtNc6hd1mX4Tq7lAreG9pjQ==\n-----END CERTIFICATE-----\n`,\n    description: \"Internal Coprorates Services Authority\",\n    metadata: \"{\\\"internal_id\\\": \\\"7d2caeee-cdc3-4b26-b2c2-b280b8287552\\\"}\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.certificate_authority.CertificateAuthority(\"example\",\n    ca_pem=-----BEGIN CERTIFICATE-----\nMIIEETCCAvmgAwIBAgIUU3N6lNzPqar4400cLQMcVHFl+mEwDQYJKoZIhvcNAQEL\nBQAwgZcxCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5l\neTEZMBcGA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQg\nU2VydmljZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9w\nYmVhci5leGFtcGxlMB4XDTIwMDUwMTE2Mjc1OVoXDTIxMDUwMTE2Mjc1OVowgZcx\nCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5leTEZMBcG\nA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQgU2Vydmlj\nZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9wYmVhci5l\neGFtcGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7y/EAN0yZkA0\nnRpMBfomnnS8KMWHb90kvGfhkCDR8WCQz5mX7eDEYDthRQrEgp63qtJ7IoCM5f0A\nUD6J2m/mZecP7SfA8OuTAZ7UyRixpZh0zJQSgj24Sh1LQuYci0DNXrei+R1qBvd+\npmpZwkKygNrbZYe3oY1PZ3jEYPSAQzIObDF7LhdhLLrcfWa9BHOGMLnALNMY558b\nvoijTCEmRrSavdvrAS9LDRipEXT8EQOWZZT9VbPtgSBalvStdoupAptmPIWjXftf\nWi1kry+P0xVFZG9iZwUeAT6fSJ+gJD8M1UXWaQbocYrctESP0sZEFM3rzdWqrZb7\n3cH3K5OCvwIDAQABo1MwUTAdBgNVHQ4EFgQUsZdchgUimRHLiPRWw51+DGBmlfMw\nHwYDVR0jBBgwFoAUsZdchgUimRHLiPRWw51+DGBmlfMwDwYDVR0TAQH/BAUwAwEB\n/zANBgkqhkiG9w0BAQsFAAOCAQEANk25tt8sSfn6Qu1bbhWRbjKgS5z+j9LqyCna\nv3fbSchMthaQR7w0vL69ayroeYdqDZkRMmHjuYKY4NyqyXkkaqVO63wEicCo55d9\npIKuPzc/7xwdRephosjGTQ4QaQ4OnrdpJZieI92m9ODexgsab84AYmwNpbGOI/tK\nnPsQr8x1RfLs2gbBwQ4MYVM3tQQbX0o+yve5nz/NCOq4vdG+eKON5u6VYMkOOg9F\nVyNY1iISQkpNk/AF6Vi9BGuDb5Hg0phEl1Q0ntCO7ZHAUHjy0ucqXZiXoXdXZcs3\n3zKKLUKva59EDBZ5TUucvXh8VemBtNc6hd1mX4Tq7lAreG9pjQ==\n-----END CERTIFICATE-----\n,\n    description=Internal Coprorates Services Authority,\n    metadata={\"internal_id\": \"7d2caeee-cdc3-4b26-b2c2-b280b8287552\"})\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.CertificateAuthority.CertificateAuthority(\"example\", new()\n    {\n        CaPem = @\"-----BEGIN CERTIFICATE-----\nMIIEETCCAvmgAwIBAgIUU3N6lNzPqar4400cLQMcVHFl+mEwDQYJKoZIhvcNAQEL\nBQAwgZcxCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5l\neTEZMBcGA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQg\nU2VydmljZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9w\nYmVhci5leGFtcGxlMB4XDTIwMDUwMTE2Mjc1OVoXDTIxMDUwMTE2Mjc1OVowgZcx\nCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5leTEZMBcG\nA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQgU2Vydmlj\nZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9wYmVhci5l\neGFtcGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7y/EAN0yZkA0\nnRpMBfomnnS8KMWHb90kvGfhkCDR8WCQz5mX7eDEYDthRQrEgp63qtJ7IoCM5f0A\nUD6J2m/mZecP7SfA8OuTAZ7UyRixpZh0zJQSgj24Sh1LQuYci0DNXrei+R1qBvd+\npmpZwkKygNrbZYe3oY1PZ3jEYPSAQzIObDF7LhdhLLrcfWa9BHOGMLnALNMY558b\nvoijTCEmRrSavdvrAS9LDRipEXT8EQOWZZT9VbPtgSBalvStdoupAptmPIWjXftf\nWi1kry+P0xVFZG9iZwUeAT6fSJ+gJD8M1UXWaQbocYrctESP0sZEFM3rzdWqrZb7\n3cH3K5OCvwIDAQABo1MwUTAdBgNVHQ4EFgQUsZdchgUimRHLiPRWw51+DGBmlfMw\nHwYDVR0jBBgwFoAUsZdchgUimRHLiPRWw51+DGBmlfMwDwYDVR0TAQH/BAUwAwEB\n/zANBgkqhkiG9w0BAQsFAAOCAQEANk25tt8sSfn6Qu1bbhWRbjKgS5z+j9LqyCna\nv3fbSchMthaQR7w0vL69ayroeYdqDZkRMmHjuYKY4NyqyXkkaqVO63wEicCo55d9\npIKuPzc/7xwdRephosjGTQ4QaQ4OnrdpJZieI92m9ODexgsab84AYmwNpbGOI/tK\nnPsQr8x1RfLs2gbBwQ4MYVM3tQQbX0o+yve5nz/NCOq4vdG+eKON5u6VYMkOOg9F\nVyNY1iISQkpNk/AF6Vi9BGuDb5Hg0phEl1Q0ntCO7ZHAUHjy0ucqXZiXoXdXZcs3\n3zKKLUKva59EDBZ5TUucvXh8VemBtNc6hd1mX4Tq7lAreG9pjQ==\n-----END CERTIFICATE-----\n\",\n        Description = \"Internal Coprorates Services Authority\",\n        Metadata = \"{\\\"internal_id\\\": \\\"7d2caeee-cdc3-4b26-b2c2-b280b8287552\\\"}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewCertificateAuthority(ctx, \"example\", \u0026ngrok.CertificateAuthorityArgs{\n\t\t\tCaPem: `-----BEGIN CERTIFICATE-----\nMIIEETCCAvmgAwIBAgIUU3N6lNzPqar4400cLQMcVHFl+mEwDQYJKoZIhvcNAQEL\nBQAwgZcxCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5l\neTEZMBcGA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQg\nU2VydmljZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9w\nYmVhci5leGFtcGxlMB4XDTIwMDUwMTE2Mjc1OVoXDTIxMDUwMTE2Mjc1OVowgZcx\nCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5leTEZMBcG\nA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQgU2Vydmlj\nZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9wYmVhci5l\neGFtcGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7y/EAN0yZkA0\nnRpMBfomnnS8KMWHb90kvGfhkCDR8WCQz5mX7eDEYDthRQrEgp63qtJ7IoCM5f0A\nUD6J2m/mZecP7SfA8OuTAZ7UyRixpZh0zJQSgj24Sh1LQuYci0DNXrei+R1qBvd+\npmpZwkKygNrbZYe3oY1PZ3jEYPSAQzIObDF7LhdhLLrcfWa9BHOGMLnALNMY558b\nvoijTCEmRrSavdvrAS9LDRipEXT8EQOWZZT9VbPtgSBalvStdoupAptmPIWjXftf\nWi1kry+P0xVFZG9iZwUeAT6fSJ+gJD8M1UXWaQbocYrctESP0sZEFM3rzdWqrZb7\n3cH3K5OCvwIDAQABo1MwUTAdBgNVHQ4EFgQUsZdchgUimRHLiPRWw51+DGBmlfMw\nHwYDVR0jBBgwFoAUsZdchgUimRHLiPRWw51+DGBmlfMwDwYDVR0TAQH/BAUwAwEB\n/zANBgkqhkiG9w0BAQsFAAOCAQEANk25tt8sSfn6Qu1bbhWRbjKgS5z+j9LqyCna\nv3fbSchMthaQR7w0vL69ayroeYdqDZkRMmHjuYKY4NyqyXkkaqVO63wEicCo55d9\npIKuPzc/7xwdRephosjGTQ4QaQ4OnrdpJZieI92m9ODexgsab84AYmwNpbGOI/tK\nnPsQr8x1RfLs2gbBwQ4MYVM3tQQbX0o+yve5nz/NCOq4vdG+eKON5u6VYMkOOg9F\nVyNY1iISQkpNk/AF6Vi9BGuDb5Hg0phEl1Q0ntCO7ZHAUHjy0ucqXZiXoXdXZcs3\n3zKKLUKva59EDBZ5TUucvXh8VemBtNc6hd1mX4Tq7lAreG9pjQ==\n-----END CERTIFICATE-----\n`,\n\t\t\tDescription: \"Internal Coprorates Services Authority\",\n\t\t\tMetadata:    \"{\\\"internal_id\\\": \\\"7d2caeee-cdc3-4b26-b2c2-b280b8287552\\\"}\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.CertificateAuthority;\nimport com.pulumi.ngrok.CertificateAuthorityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CertificateAuthority(\"example\", CertificateAuthorityArgs.builder()        \n            .caPem(\"\"\"\n-----BEGIN CERTIFICATE-----\nMIIEETCCAvmgAwIBAgIUU3N6lNzPqar4400cLQMcVHFl+mEwDQYJKoZIhvcNAQEL\nBQAwgZcxCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5l\neTEZMBcGA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQg\nU2VydmljZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9w\nYmVhci5leGFtcGxlMB4XDTIwMDUwMTE2Mjc1OVoXDTIxMDUwMTE2Mjc1OVowgZcx\nCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5leTEZMBcG\nA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQgU2Vydmlj\nZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9wYmVhci5l\neGFtcGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7y/EAN0yZkA0\nnRpMBfomnnS8KMWHb90kvGfhkCDR8WCQz5mX7eDEYDthRQrEgp63qtJ7IoCM5f0A\nUD6J2m/mZecP7SfA8OuTAZ7UyRixpZh0zJQSgj24Sh1LQuYci0DNXrei+R1qBvd+\npmpZwkKygNrbZYe3oY1PZ3jEYPSAQzIObDF7LhdhLLrcfWa9BHOGMLnALNMY558b\nvoijTCEmRrSavdvrAS9LDRipEXT8EQOWZZT9VbPtgSBalvStdoupAptmPIWjXftf\nWi1kry+P0xVFZG9iZwUeAT6fSJ+gJD8M1UXWaQbocYrctESP0sZEFM3rzdWqrZb7\n3cH3K5OCvwIDAQABo1MwUTAdBgNVHQ4EFgQUsZdchgUimRHLiPRWw51+DGBmlfMw\nHwYDVR0jBBgwFoAUsZdchgUimRHLiPRWw51+DGBmlfMwDwYDVR0TAQH/BAUwAwEB\n/zANBgkqhkiG9w0BAQsFAAOCAQEANk25tt8sSfn6Qu1bbhWRbjKgS5z+j9LqyCna\nv3fbSchMthaQR7w0vL69ayroeYdqDZkRMmHjuYKY4NyqyXkkaqVO63wEicCo55d9\npIKuPzc/7xwdRephosjGTQ4QaQ4OnrdpJZieI92m9ODexgsab84AYmwNpbGOI/tK\nnPsQr8x1RfLs2gbBwQ4MYVM3tQQbX0o+yve5nz/NCOq4vdG+eKON5u6VYMkOOg9F\nVyNY1iISQkpNk/AF6Vi9BGuDb5Hg0phEl1Q0ntCO7ZHAUHjy0ucqXZiXoXdXZcs3\n3zKKLUKva59EDBZ5TUucvXh8VemBtNc6hd1mX4Tq7lAreG9pjQ==\n-----END CERTIFICATE-----\n            \"\"\")\n            .description(\"Internal Coprorates Services Authority\")\n            .metadata(\"{\\\"internal_id\\\": \\\"7d2caeee-cdc3-4b26-b2c2-b280b8287552\\\"}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:CertificateAuthority\n    properties:\n      caPem: |\n        -----BEGIN CERTIFICATE-----\n        MIIEETCCAvmgAwIBAgIUU3N6lNzPqar4400cLQMcVHFl+mEwDQYJKoZIhvcNAQEL\n        BQAwgZcxCzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5l\n        eTEZMBcGA1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQg\n        U2VydmljZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9w\n        YmVhci5leGFtcGxlMB4XDTIwMDUwMTE2Mjc1OVoXDTIxMDUwMTE2Mjc1OVowgZcx\n        CzAJBgNVBAYTAkFVMQwwCgYDVQQIDANOU1cxDzANBgNVBAcMBlN5ZG5leTEZMBcG\n        A1UECgwQRHJvcGJlYXIgUHR5IEx0ZDEkMCIGA1UEAwwbSW50cmFuZXQgU2Vydmlj\n        ZXMgQXV0aG9yaXR5MSgwJgYJKoZIhvcNAQkBFhlzZWN1cml0eUBkcm9wYmVhci5l\n        eGFtcGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7y/EAN0yZkA0\n        nRpMBfomnnS8KMWHb90kvGfhkCDR8WCQz5mX7eDEYDthRQrEgp63qtJ7IoCM5f0A\n        UD6J2m/mZecP7SfA8OuTAZ7UyRixpZh0zJQSgj24Sh1LQuYci0DNXrei+R1qBvd+\n        pmpZwkKygNrbZYe3oY1PZ3jEYPSAQzIObDF7LhdhLLrcfWa9BHOGMLnALNMY558b\n        voijTCEmRrSavdvrAS9LDRipEXT8EQOWZZT9VbPtgSBalvStdoupAptmPIWjXftf\n        Wi1kry+P0xVFZG9iZwUeAT6fSJ+gJD8M1UXWaQbocYrctESP0sZEFM3rzdWqrZb7\n        3cH3K5OCvwIDAQABo1MwUTAdBgNVHQ4EFgQUsZdchgUimRHLiPRWw51+DGBmlfMw\n        HwYDVR0jBBgwFoAUsZdchgUimRHLiPRWw51+DGBmlfMwDwYDVR0TAQH/BAUwAwEB\n        /zANBgkqhkiG9w0BAQsFAAOCAQEANk25tt8sSfn6Qu1bbhWRbjKgS5z+j9LqyCna\n        v3fbSchMthaQR7w0vL69ayroeYdqDZkRMmHjuYKY4NyqyXkkaqVO63wEicCo55d9\n        pIKuPzc/7xwdRephosjGTQ4QaQ4OnrdpJZieI92m9ODexgsab84AYmwNpbGOI/tK\n        nPsQr8x1RfLs2gbBwQ4MYVM3tQQbX0o+yve5nz/NCOq4vdG+eKON5u6VYMkOOg9F\n        VyNY1iISQkpNk/AF6Vi9BGuDb5Hg0phEl1Q0ntCO7ZHAUHjy0ucqXZiXoXdXZcs3\n        3zKKLUKva59EDBZ5TUucvXh8VemBtNc6hd1mX4Tq7lAreG9pjQ==\n        -----END CERTIFICATE-----\n      description: Internal Coprorates Services Authority\n      metadata: '{\"internal_id\": \"7d2caeee-cdc3-4b26-b2c2-b280b8287552\"}'\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "caPem": {
                    "type": "string",
                    "description": "raw PEM of the Certificate Authority\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of this Certificate Authority. optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.\n"
                }
            },
            "required": [
                "caPem"
            ],
            "inputProperties": {
                "caPem": {
                    "type": "string",
                    "description": "raw PEM of the Certificate Authority\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of this Certificate Authority. optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.\n"
                }
            },
            "requiredInputs": [
                "caPem"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertificateAuthority resources.\n",
                "properties": {
                    "caPem": {
                        "type": "string",
                        "description": "raw PEM of the Certificate Authority\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of this Certificate Authority. optional, max 255 bytes.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.\n"
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/credential:Credential": {
            "description": "Tunnel Credentials are ngrok agent authtokens. They authorize the ngrok\n agent to connect the ngrok service as your account. They are installed with\n the `ngrok authtoken` command or by specifying it in the `ngrok.yml`\n configuration file with the `authtoken` property.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/credential.Credential(\"example\", {description: \"development cred for alan@example.com\"});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.credential.Credential(\"example\", description=development cred for alan@example.com)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.Credential.Credential(\"example\", new()\n    {\n        Description = \"development cred for alan@example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewCredential(ctx, \"example\", \u0026ngrok.CredentialArgs{\n\t\t\tDescription: \"development cred for alan@example.com\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.Credential;\nimport com.pulumi.ngrok.CredentialArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Credential(\"example\", CredentialArgs.builder()        \n            .description(\"development cred for alan@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:Credential\n    properties:\n      description: development cred for alan@example.com\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "acls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.\n"
                },
                "token": {
                    "type": "string",
                    "description": "the credential's authtoken that can be used to authenticate an ngrok client. **This value is only available one time, on the API response from credential creation, otherwise it is null.**\n",
                    "secret": true
                }
            },
            "required": [
                "token"
            ],
            "inputProperties": {
                "acls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Credential resources.\n",
                "properties": {
                    "acls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "the credential's authtoken that can be used to authenticate an ngrok client. **This value is only available one time, on the API response from credential creation, otherwise it is null.**\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/endpointConfiguration:EndpointConfiguration": {
            "description": "Endpoint Configurations are a reusable group of modules that encapsulate how\n traffic to a domain or address is handled. Endpoint configurations are only\n applied to Domains and TCP Addresses they have been attached to.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/endpointConfiguration.EndpointConfiguration(\"example\", {\n    description: \"app servers\",\n    requestHeaders: [{\n        add: {\n            \"x-frontend\": \"ngrok\",\n        },\n        removes: [\"cache-control\"],\n    }],\n    type: \"https\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.endpoint_configuration.EndpointConfiguration(\"example\",\n    description=app servers,\n    request_headers=[{\n        add: {\n            x-frontend: ngrok,\n        },\n        removes: [cache-control],\n    }],\n    type=https)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.EndpointConfiguration.EndpointConfiguration(\"example\", new()\n    {\n        Description = \"app servers\",\n        RequestHeaders = new[]\n        {\n            \n            {\n                { \"add\", \n                {\n                    { \"x-frontend\", \"ngrok\" },\n                } },\n                { \"removes\", new[]\n                {\n                    \"cache-control\",\n                } },\n            },\n        },\n        Type = \"https\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewEndpointConfiguration(ctx, \"example\", \u0026ngrok.EndpointConfigurationArgs{\n\t\t\tDescription: \"app servers\",\n\t\t\tRequestHeaders: []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"add\": map[string]interface{}{\n\t\t\t\t\t\t\"x-frontend\": \"ngrok\",\n\t\t\t\t\t},\n\t\t\t\t\t\"removes\": []string{\n\t\t\t\t\t\t\"cache-control\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tType: \"https\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.EndpointConfiguration;\nimport com.pulumi.ngrok.EndpointConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new EndpointConfiguration(\"example\", EndpointConfigurationArgs.builder()        \n            .description(\"app servers\")\n            .requestHeaders(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .type(\"https\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:EndpointConfiguration\n    properties:\n      description: app servers\n      requestHeaders:\n        - add:\n            x-frontend: ngrok\n          removes:\n            - cache-control\n      type: https\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backends": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationBackend:EndpointConfigurationBackend"
                    },
                    "description": "backend module configuration or `null`\n"
                },
                "basicAuths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationBasicAuth:EndpointConfigurationBasicAuth"
                    },
                    "description": "basic auth module configuration or `null`\n"
                },
                "circuitBreakers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationCircuitBreaker:EndpointConfigurationCircuitBreaker"
                    },
                    "description": "circuit breaker module configuration or `null`\n"
                },
                "compressions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationCompression:EndpointConfigurationCompression"
                    },
                    "description": "compression module configuration or `null`\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of what this endpoint configuration will be do when applied or what traffic it will be applied to. Optional, max 255 bytes\n"
                },
                "ipPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationIpPolicy:EndpointConfigurationIpPolicy"
                    },
                    "description": "ip policy module configuration or `null`\n"
                },
                "loggings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationLogging:EndpointConfigurationLogging"
                    },
                    "description": "logging module configuration or `null`\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this endpoint configuration. Optional, max 4096 bytes.\n"
                },
                "mutualTls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationMutualTl:EndpointConfigurationMutualTl"
                    },
                    "description": "mutual TLS module configuration or `null`\n"
                },
                "oauths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationOauth:EndpointConfigurationOauth"
                    },
                    "description": "oauth module configuration or `null`\n"
                },
                "oidcs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationOidc:EndpointConfigurationOidc"
                    },
                    "description": "oidc module configuration or `null`\n"
                },
                "requestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationRequestHeader:EndpointConfigurationRequestHeader"
                    },
                    "description": "request headers module configuration or `null`\n"
                },
                "responseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationResponseHeader:EndpointConfigurationResponseHeader"
                    },
                    "description": "response headers module configuration or `null`\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationSaml:EndpointConfigurationSaml"
                    },
                    "description": "saml module configuration or `null`\n"
                },
                "tlsTerminations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationTlsTermination:EndpointConfigurationTlsTermination"
                    },
                    "description": "TLS termination module configuration or `null`\n"
                },
                "type": {
                    "type": "string",
                    "description": "they type of traffic this endpoint configuration can be applied to. one of: `http`, `https`, `tcp`\n"
                },
                "webhookValidations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationWebhookValidation:EndpointConfigurationWebhookValidation"
                    },
                    "description": "webhook validation module configuration or `null`\n"
                }
            },
            "inputProperties": {
                "backends": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationBackend:EndpointConfigurationBackend"
                    },
                    "description": "backend module configuration or `null`\n"
                },
                "basicAuths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationBasicAuth:EndpointConfigurationBasicAuth"
                    },
                    "description": "basic auth module configuration or `null`\n"
                },
                "circuitBreakers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationCircuitBreaker:EndpointConfigurationCircuitBreaker"
                    },
                    "description": "circuit breaker module configuration or `null`\n"
                },
                "compressions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationCompression:EndpointConfigurationCompression"
                    },
                    "description": "compression module configuration or `null`\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of what this endpoint configuration will be do when applied or what traffic it will be applied to. Optional, max 255 bytes\n"
                },
                "ipPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationIpPolicy:EndpointConfigurationIpPolicy"
                    },
                    "description": "ip policy module configuration or `null`\n"
                },
                "loggings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationLogging:EndpointConfigurationLogging"
                    },
                    "description": "logging module configuration or `null`\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this endpoint configuration. Optional, max 4096 bytes.\n"
                },
                "mutualTls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationMutualTl:EndpointConfigurationMutualTl"
                    },
                    "description": "mutual TLS module configuration or `null`\n"
                },
                "oauths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationOauth:EndpointConfigurationOauth"
                    },
                    "description": "oauth module configuration or `null`\n"
                },
                "oidcs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationOidc:EndpointConfigurationOidc"
                    },
                    "description": "oidc module configuration or `null`\n"
                },
                "requestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationRequestHeader:EndpointConfigurationRequestHeader"
                    },
                    "description": "request headers module configuration or `null`\n"
                },
                "responseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationResponseHeader:EndpointConfigurationResponseHeader"
                    },
                    "description": "response headers module configuration or `null`\n"
                },
                "samls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationSaml:EndpointConfigurationSaml"
                    },
                    "description": "saml module configuration or `null`\n"
                },
                "tlsTerminations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationTlsTermination:EndpointConfigurationTlsTermination"
                    },
                    "description": "TLS termination module configuration or `null`\n"
                },
                "type": {
                    "type": "string",
                    "description": "they type of traffic this endpoint configuration can be applied to. one of: `http`, `https`, `tcp`\n",
                    "willReplaceOnChanges": true
                },
                "webhookValidations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EndpointConfigurationWebhookValidation:EndpointConfigurationWebhookValidation"
                    },
                    "description": "webhook validation module configuration or `null`\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EndpointConfiguration resources.\n",
                "properties": {
                    "backends": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationBackend:EndpointConfigurationBackend"
                        },
                        "description": "backend module configuration or `null`\n"
                    },
                    "basicAuths": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationBasicAuth:EndpointConfigurationBasicAuth"
                        },
                        "description": "basic auth module configuration or `null`\n"
                    },
                    "circuitBreakers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationCircuitBreaker:EndpointConfigurationCircuitBreaker"
                        },
                        "description": "circuit breaker module configuration or `null`\n"
                    },
                    "compressions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationCompression:EndpointConfigurationCompression"
                        },
                        "description": "compression module configuration or `null`\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of what this endpoint configuration will be do when applied or what traffic it will be applied to. Optional, max 255 bytes\n"
                    },
                    "ipPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationIpPolicy:EndpointConfigurationIpPolicy"
                        },
                        "description": "ip policy module configuration or `null`\n"
                    },
                    "loggings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationLogging:EndpointConfigurationLogging"
                        },
                        "description": "logging module configuration or `null`\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this endpoint configuration. Optional, max 4096 bytes.\n"
                    },
                    "mutualTls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationMutualTl:EndpointConfigurationMutualTl"
                        },
                        "description": "mutual TLS module configuration or `null`\n"
                    },
                    "oauths": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationOauth:EndpointConfigurationOauth"
                        },
                        "description": "oauth module configuration or `null`\n"
                    },
                    "oidcs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationOidc:EndpointConfigurationOidc"
                        },
                        "description": "oidc module configuration or `null`\n"
                    },
                    "requestHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationRequestHeader:EndpointConfigurationRequestHeader"
                        },
                        "description": "request headers module configuration or `null`\n"
                    },
                    "responseHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationResponseHeader:EndpointConfigurationResponseHeader"
                        },
                        "description": "response headers module configuration or `null`\n"
                    },
                    "samls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationSaml:EndpointConfigurationSaml"
                        },
                        "description": "saml module configuration or `null`\n"
                    },
                    "tlsTerminations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationTlsTermination:EndpointConfigurationTlsTermination"
                        },
                        "description": "TLS termination module configuration or `null`\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "they type of traffic this endpoint configuration can be applied to. one of: `http`, `https`, `tcp`\n",
                        "willReplaceOnChanges": true
                    },
                    "webhookValidations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EndpointConfigurationWebhookValidation:EndpointConfigurationWebhookValidation"
                        },
                        "description": "webhook validation module configuration or `null`\n"
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/eventDestination:EventDestination": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/eventDestination.EventDestination(\"example\", {\n    description: \"kinesis dev stream\",\n    format: \"json\",\n    metadata: \"{\\\"environment\\\":\\\"dev\\\"}\",\n    targets: [{\n        kineses: [{\n            auth: [{\n                role: [{\n                    roleArn: \"arn:aws:iam::123456789012:role/example\",\n                }],\n            }],\n            streamArn: \"arn:ngrok-local:kinesis:us-east-2:123456789012:stream/mystream2\",\n        }],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.event_destination.EventDestination(\"example\",\n    description=kinesis dev stream,\n    format=json,\n    metadata={\"environment\":\"dev\"},\n    targets=[{\n        kineses: [{\n            auth: [{\n                role: [{\n                    roleArn: arn:aws:iam::123456789012:role/example,\n                }],\n            }],\n            streamArn: arn:ngrok-local:kinesis:us-east-2:123456789012:stream/mystream2,\n        }],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.EventDestination.EventDestination(\"example\", new()\n    {\n        Description = \"kinesis dev stream\",\n        Format = \"json\",\n        Metadata = \"{\\\"environment\\\":\\\"dev\\\"}\",\n        Targets = new[]\n        {\n            \n            {\n                { \"kineses\", new[]\n                {\n                    \n                    {\n                        { \"auth\", new[]\n                        {\n                            \n                            {\n                                { \"role\", new[]\n                                {\n                                    \n                                    {\n                                        { \"roleArn\", \"arn:aws:iam::123456789012:role/example\" },\n                                    },\n                                } },\n                            },\n                        } },\n                        { \"streamArn\", \"arn:ngrok-local:kinesis:us-east-2:123456789012:stream/mystream2\" },\n                    },\n                } },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewEventDestination(ctx, \"example\", \u0026ngrok.EventDestinationArgs{\n\t\t\tDescription: \"kinesis dev stream\",\n\t\t\tFormat:      \"json\",\n\t\t\tMetadata:    \"{\\\"environment\\\":\\\"dev\\\"}\",\n\t\t\tTargets: []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"kineses\": []map[string]interface{}{\n\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\"auth\": []map[string]interface{}{\n\t\t\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\t\t\"role\": []map[string]interface{}{\n\t\t\t\t\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\t\t\t\t\"roleArn\": \"arn:aws:iam::123456789012:role/example\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"streamArn\": \"arn:ngrok-local:kinesis:us-east-2:123456789012:stream/mystream2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.EventDestination;\nimport com.pulumi.ngrok.EventDestinationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new EventDestination(\"example\", EventDestinationArgs.builder()        \n            .description(\"kinesis dev stream\")\n            .format(\"json\")\n            .metadata(\"{\\\"environment\\\":\\\"dev\\\"}\")\n            .targets(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:EventDestination\n    properties:\n      description: kinesis dev stream\n      format: json\n      metadata: '{\"environment\":\"dev\"}'\n      targets:\n        - kineses:\n            - auth:\n                - role:\n                    - roleArn: arn:aws:iam::123456789012:role/example\n              streamArn: arn:ngrok-local:kinesis:us-east-2:123456789012:stream/mystream2\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Human-readable description of the Event Destination. Optional, max 255 bytes.\n"
                },
                "format": {
                    "type": "string",
                    "description": "The output format you would like to serialize events into when sending to their target. Currently the only accepted value is `JSON`.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.\n"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTarget:EventDestinationTarget"
                    },
                    "description": "An object that encapsulates where and how to send your events. An event destination must contain exactly one of the following objects, leaving the rest null: `kinesis`, `firehose`, `cloudwatch_logs`, or `s3`.\n"
                },
                "verifyWithTestEvent": {
                    "type": "boolean"
                }
            },
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Human-readable description of the Event Destination. Optional, max 255 bytes.\n"
                },
                "format": {
                    "type": "string",
                    "description": "The output format you would like to serialize events into when sending to their target. Currently the only accepted value is `JSON`.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.\n"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventDestinationTarget:EventDestinationTarget"
                    },
                    "description": "An object that encapsulates where and how to send your events. An event destination must contain exactly one of the following objects, leaving the rest null: `kinesis`, `firehose`, `cloudwatch_logs`, or `s3`.\n"
                },
                "verifyWithTestEvent": {
                    "type": "boolean"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EventDestination resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Human-readable description of the Event Destination. Optional, max 255 bytes.\n"
                    },
                    "format": {
                        "type": "string",
                        "description": "The output format you would like to serialize events into when sending to their target. Currently the only accepted value is `JSON`.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.\n"
                    },
                    "targets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EventDestinationTarget:EventDestinationTarget"
                        },
                        "description": "An object that encapsulates where and how to send your events. An event destination must contain exactly one of the following objects, leaving the rest null: `kinesis`, `firehose`, `cloudwatch_logs`, or `s3`.\n"
                    },
                    "verifyWithTestEvent": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/eventSubscription:EventSubscription": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.\n"
                },
                "destinationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Event Destination IDs which should be used for this Event Subscription.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.\n"
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventSubscriptionSource:EventSubscriptionSource"
                    },
                    "description": "Sources containing the types for which this event subscription will trigger\n"
                }
            },
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.\n"
                },
                "destinationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of Event Destination IDs which should be used for this Event Subscription.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.\n"
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/EventSubscriptionSource:EventSubscriptionSource"
                    },
                    "description": "Sources containing the types for which this event subscription will trigger\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EventSubscription resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.\n"
                    },
                    "destinationIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of Event Destination IDs which should be used for this Event Subscription.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.\n"
                    },
                    "sources": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/EventSubscriptionSource:EventSubscriptionSource"
                        },
                        "description": "Sources containing the types for which this event subscription will trigger\n"
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/ipPolicy:IpPolicy": {
            "description": "IP Policies are reusable groups of CIDR ranges with an `allow` or `deny`\n action. They can be attached to endpoints via the Endpoint Configuration IP\n Policy module. They can also be used with IP Restrictions to control source\n IP ranges that can start tunnel sessions and connect to the API and dashboard.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/ipPolicy.IpPolicy(\"example\", {\n    action: \"allow\",\n    description: \"API Outbound Gateway\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.ip_policy.IpPolicy(\"example\",\n    action=allow,\n    description=API Outbound Gateway)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.IpPolicy.IpPolicy(\"example\", new()\n    {\n        Action = \"allow\",\n        Description = \"API Outbound Gateway\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewIpPolicy(ctx, \"example\", \u0026ngrok.IpPolicyArgs{\n\t\t\tAction:      \"allow\",\n\t\t\tDescription: \"API Outbound Gateway\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.IpPolicy;\nimport com.pulumi.ngrok.IpPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IpPolicy(\"example\", IpPolicyArgs.builder()        \n            .action(\"allow\")\n            .description(\"API Outbound Gateway\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:IpPolicy\n    properties:\n      action: allow\n      description: API Outbound Gateway\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "this field is deprecated. Please leave it empty and use the ip policy rule object's \"action\" field instead. It is temporarily retained for backwards compatibility reasons.\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of the source IPs of this IP policy. optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.\n"
                }
            },
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": "this field is deprecated. Please leave it empty and use the ip policy rule object's \"action\" field instead. It is temporarily retained for backwards compatibility reasons.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of the source IPs of this IP policy. optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpPolicy resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "this field is deprecated. Please leave it empty and use the ip policy rule object's \"action\" field instead. It is temporarily retained for backwards compatibility reasons.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of the source IPs of this IP policy. optional, max 255 bytes.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.\n"
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/ipPolicyRule:IpPolicyRule": {
            "description": "IP Policy Rules are the IPv4 or IPv6 CIDRs entries that\n make up an IP Policy.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/ipPolicyRule.IpPolicyRule(\"example\", {\n    cidr: \"212.3.14.0/24\",\n    description: \"nyc office\",\n    ipPolicyId: \"ipp_25auGv9R7vPmi6NKs5Cxcyzc2Cm\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.ip_policy_rule.IpPolicyRule(\"example\",\n    cidr=212.3.14.0/24,\n    description=nyc office,\n    ip_policy_id=ipp_25auGv9R7vPmi6NKs5Cxcyzc2Cm)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.IpPolicyRule.IpPolicyRule(\"example\", new()\n    {\n        Cidr = \"212.3.14.0/24\",\n        Description = \"nyc office\",\n        IpPolicyId = \"ipp_25auGv9R7vPmi6NKs5Cxcyzc2Cm\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewIpPolicyRule(ctx, \"example\", \u0026ngrok.IpPolicyRuleArgs{\n\t\t\tCidr:        \"212.3.14.0/24\",\n\t\t\tDescription: \"nyc office\",\n\t\t\tIpPolicyId:  \"ipp_25auGv9R7vPmi6NKs5Cxcyzc2Cm\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.IpPolicyRule;\nimport com.pulumi.ngrok.IpPolicyRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IpPolicyRule(\"example\", IpPolicyRuleArgs.builder()        \n            .cidr(\"212.3.14.0/24\")\n            .description(\"nyc office\")\n            .ipPolicyId(\"ipp_25auGv9R7vPmi6NKs5Cxcyzc2Cm\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:IpPolicyRule\n    properties:\n      cidr: 212.3.14.0/24\n      description: nyc office\n      ipPolicyId: ipp_25auGv9R7vPmi6NKs5Cxcyzc2Cm\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "the action to apply to the policy rule, either `allow` or `deny`\n"
                },
                "cidr": {
                    "type": "string",
                    "description": "an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of the source IPs of this IP rule. optional, max 255 bytes.\n"
                },
                "ipPolicyId": {
                    "type": "string",
                    "description": "ID of the IP policy this IP policy rule will be attached to\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.\n"
                }
            },
            "required": [
                "cidr",
                "ipPolicyId"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": "the action to apply to the policy rule, either `allow` or `deny`\n",
                    "willReplaceOnChanges": true
                },
                "cidr": {
                    "type": "string",
                    "description": "an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of the source IPs of this IP rule. optional, max 255 bytes.\n"
                },
                "ipPolicyId": {
                    "type": "string",
                    "description": "ID of the IP policy this IP policy rule will be attached to\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.\n"
                }
            },
            "requiredInputs": [
                "cidr",
                "ipPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpPolicyRule resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "the action to apply to the policy rule, either `allow` or `deny`\n",
                        "willReplaceOnChanges": true
                    },
                    "cidr": {
                        "type": "string",
                        "description": "an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of the source IPs of this IP rule. optional, max 255 bytes.\n"
                    },
                    "ipPolicyId": {
                        "type": "string",
                        "description": "ID of the IP policy this IP policy rule will be attached to\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.\n"
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/ipRestriction:IpRestriction": {
            "description": "An IP restriction is a restriction placed on the CIDRs that are allowed to\n initiate traffic to a specific aspect of your ngrok account. An IP\n restriction has a type which defines the ingress it applies to. IP\n restrictions can be used to enforce the source IPs that can make API\n requests, log in to the dashboard, start ngrok agents, and connect to your\n public-facing endpoints.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/ipRestriction.IpRestriction(\"example\", {\n    ipPolicyIds: [\"ipp_25auGwa4eEWUeCOBfCZkwtwqFey\"],\n    type: \"dashboard\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.ip_restriction.IpRestriction(\"example\",\n    ip_policy_ids=[ipp_25auGwa4eEWUeCOBfCZkwtwqFey],\n    type=dashboard)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.IpRestriction.IpRestriction(\"example\", new()\n    {\n        IpPolicyIds = new[]\n        {\n            \"ipp_25auGwa4eEWUeCOBfCZkwtwqFey\",\n        },\n        Type = \"dashboard\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewIpRestriction(ctx, \"example\", \u0026ngrok.IpRestrictionArgs{\n\t\t\tIpPolicyIds: []string{\n\t\t\t\t\"ipp_25auGwa4eEWUeCOBfCZkwtwqFey\",\n\t\t\t},\n\t\t\tType: \"dashboard\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.IpRestriction;\nimport com.pulumi.ngrok.IpRestrictionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IpRestriction(\"example\", IpRestrictionArgs.builder()        \n            .ipPolicyIds(\"ipp_25auGwa4eEWUeCOBfCZkwtwqFey\")\n            .type(\"dashboard\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:IpRestriction\n    properties:\n      ipPolicyIds:\n        - ipp_25auGwa4eEWUeCOBfCZkwtwqFey\n      type: dashboard\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "human-readable description of this IP restriction. optional, max 255 bytes.\n"
                },
                "enforced": {
                    "type": "boolean",
                    "description": "true if the IP restriction will be enforced. if false, only warnings will be issued\n"
                },
                "ipPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "the set of IP policy identifiers that are used to enforce the restriction\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.\n"
                },
                "type": {
                    "type": "string",
                    "description": "the type of IP restriction. this defines what traffic will be restricted with the attached policies. four values are currently supported: `dashboard`, `api`, `agent`, and `endpoints`\n"
                }
            },
            "required": [
                "ipPolicyIds",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "human-readable description of this IP restriction. optional, max 255 bytes.\n"
                },
                "enforced": {
                    "type": "boolean",
                    "description": "true if the IP restriction will be enforced. if false, only warnings will be issued\n"
                },
                "ipPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "the set of IP policy identifiers that are used to enforce the restriction\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.\n"
                },
                "type": {
                    "type": "string",
                    "description": "the type of IP restriction. this defines what traffic will be restricted with the attached policies. four values are currently supported: `dashboard`, `api`, `agent`, and `endpoints`\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "ipPolicyIds",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpRestriction resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "human-readable description of this IP restriction. optional, max 255 bytes.\n"
                    },
                    "enforced": {
                        "type": "boolean",
                        "description": "true if the IP restriction will be enforced. if false, only warnings will be issued\n"
                    },
                    "ipPolicyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "the set of IP policy identifiers that are used to enforce the restriction\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "the type of IP restriction. this defines what traffic will be restricted with the attached policies. four values are currently supported: `dashboard`, `api`, `agent`, and `endpoints`\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/reservedAddress:ReservedAddress": {
            "description": "Reserved Addresses are TCP addresses that can be used to listen for traffic.\n TCP address hostnames and ports are assigned by ngrok, they cannot be\n chosen.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/reservedAddress.ReservedAddress(\"example\", {\n    description: \"SSH for device #001\",\n    region: \"us\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.reserved_address.ReservedAddress(\"example\",\n    description=SSH for device #001,\n    region=us)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.ReservedAddress.ReservedAddress(\"example\", new()\n    {\n        Description = \"SSH for device #001\",\n        Region = \"us\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewReservedAddress(ctx, \"example\", \u0026ngrok.ReservedAddressArgs{\n\t\t\tDescription: \"SSH for device #001\",\n\t\t\tRegion:      \"us\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.ReservedAddress;\nimport com.pulumi.ngrok.ReservedAddressArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ReservedAddress(\"example\", ReservedAddressArgs.builder()        \n            .description(\"SSH for device #001\")\n            .region(\"us\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:ReservedAddress\n    properties:\n      description: 'SSH for device #001'\n      region: us\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addr": {
                    "type": "string",
                    "description": "hostname:port of the reserved address that was assigned at creation time\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of what this reserved address will be used for\n"
                },
                "endpointConfigurationId": {
                    "type": "string",
                    "description": "ID of an endpoint configuration of type tcp that will be used to handle inbound traffic to this address\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.\n"
                },
                "region": {
                    "type": "string",
                    "description": "reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)\n"
                }
            },
            "required": [
                "addr"
            ],
            "inputProperties": {
                "addr": {
                    "type": "string",
                    "description": "hostname:port of the reserved address that was assigned at creation time\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of what this reserved address will be used for\n"
                },
                "endpointConfigurationId": {
                    "type": "string",
                    "description": "ID of an endpoint configuration of type tcp that will be used to handle inbound traffic to this address\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.\n"
                },
                "region": {
                    "type": "string",
                    "description": "reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ReservedAddress resources.\n",
                "properties": {
                    "addr": {
                        "type": "string",
                        "description": "hostname:port of the reserved address that was assigned at creation time\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of what this reserved address will be used for\n"
                    },
                    "endpointConfigurationId": {
                        "type": "string",
                        "description": "ID of an endpoint configuration of type tcp that will be used to handle inbound traffic to this address\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/reservedDomain:ReservedDomain": {
            "description": "Reserved Domains are hostnames that you can listen for traffic on. Domains\n can be used to listen for http, https or tls traffic. You may use a domain\n that you own by creating a CNAME record specified in the returned resource.\n This CNAME record points traffic for that domain to ngrok's edge servers.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/reservedDomain.ReservedDomain(\"example\", {\n    certificateId: \"cert_25auGELSEngiae3wzmLLesiZn8h\",\n    region: \"us\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.reserved_domain.ReservedDomain(\"example\",\n    certificate_id=cert_25auGELSEngiae3wzmLLesiZn8h,\n    region=us)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.ReservedDomain.ReservedDomain(\"example\", new()\n    {\n        CertificateId = \"cert_25auGELSEngiae3wzmLLesiZn8h\",\n        Region = \"us\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewReservedDomain(ctx, \"example\", \u0026ngrok.ReservedDomainArgs{\n\t\t\tCertificateId: \"cert_25auGELSEngiae3wzmLLesiZn8h\",\n\t\t\tRegion:        \"us\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.ReservedDomain;\nimport com.pulumi.ngrok.ReservedDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ReservedDomain(\"example\", ReservedDomainArgs.builder()        \n            .certificateId(\"cert_25auGELSEngiae3wzmLLesiZn8h\")\n            .region(\"us\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:ReservedDomain\n    properties:\n      certificateId: cert_25auGELSEngiae3wzmLLesiZn8h\n      region: us\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "acmeChallengeCnameTarget": {
                    "type": "string",
                    "description": "DNS CNAME target for the host _acme-challenge.example.com, where example.com is your reserved domain name. This is required to issue certificates for wildcard, non-ngrok reserved domains. Must be null for non-wildcard domains and ngrok subdomains.\n"
                },
                "certificateId": {
                    "type": "string",
                    "description": "ID of a user-uploaded TLS certificate to use for connections to targeting this domain. Optional, mutually exclusive with `certificate_management_policy`.\n"
                },
                "certificateManagementPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/ReservedDomainCertificateManagementPolicy:ReservedDomainCertificateManagementPolicy"
                    },
                    "description": "configuration for automatic management of TLS certificates for this domain, or null if automatic management is disabled\n"
                },
                "cnameTarget": {
                    "type": "string",
                    "description": "DNS CNAME target for a custom hostname, or null if the reserved domain is a subdomain of *.ngrok.io\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of what this reserved domain will be used for\n"
                },
                "domain": {
                    "type": "string",
                    "description": "hostname of the reserved domain\n"
                },
                "httpEndpointConfigurationId": {
                    "type": "string",
                    "description": "ID of an endpoint configuration of type http that will be used to handle inbound http traffic to this domain\n"
                },
                "httpsEndpointConfigurationId": {
                    "type": "string",
                    "description": "ID of an endpoint configuration of type https that will be used to handle inbound https traffic to this domain\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "the domain name to reserve. It may be a full domain name like app.example.com. If the name does not contain a '.' it will reserve that subdomain on ngrok.io.\n"
                },
                "region": {
                    "type": "string",
                    "description": "reserve the domain in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)\n"
                }
            },
            "required": [
                "acmeChallengeCnameTarget",
                "cnameTarget",
                "domain",
                "name"
            ],
            "inputProperties": {
                "acmeChallengeCnameTarget": {
                    "type": "string",
                    "description": "DNS CNAME target for the host _acme-challenge.example.com, where example.com is your reserved domain name. This is required to issue certificates for wildcard, non-ngrok reserved domains. Must be null for non-wildcard domains and ngrok subdomains.\n",
                    "willReplaceOnChanges": true
                },
                "certificateId": {
                    "type": "string",
                    "description": "ID of a user-uploaded TLS certificate to use for connections to targeting this domain. Optional, mutually exclusive with `certificate_management_policy`.\n"
                },
                "certificateManagementPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/ReservedDomainCertificateManagementPolicy:ReservedDomainCertificateManagementPolicy"
                    },
                    "description": "configuration for automatic management of TLS certificates for this domain, or null if automatic management is disabled\n"
                },
                "cnameTarget": {
                    "type": "string",
                    "description": "DNS CNAME target for a custom hostname, or null if the reserved domain is a subdomain of *.ngrok.io\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of what this reserved domain will be used for\n"
                },
                "httpEndpointConfigurationId": {
                    "type": "string",
                    "description": "ID of an endpoint configuration of type http that will be used to handle inbound http traffic to this domain\n"
                },
                "httpsEndpointConfigurationId": {
                    "type": "string",
                    "description": "ID of an endpoint configuration of type https that will be used to handle inbound https traffic to this domain\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "the domain name to reserve. It may be a full domain name like app.example.com. If the name does not contain a '.' it will reserve that subdomain on ngrok.io.\n",
                    "willReplaceOnChanges": true
                },
                "region": {
                    "type": "string",
                    "description": "reserve the domain in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ReservedDomain resources.\n",
                "properties": {
                    "acmeChallengeCnameTarget": {
                        "type": "string",
                        "description": "DNS CNAME target for the host _acme-challenge.example.com, where example.com is your reserved domain name. This is required to issue certificates for wildcard, non-ngrok reserved domains. Must be null for non-wildcard domains and ngrok subdomains.\n",
                        "willReplaceOnChanges": true
                    },
                    "certificateId": {
                        "type": "string",
                        "description": "ID of a user-uploaded TLS certificate to use for connections to targeting this domain. Optional, mutually exclusive with `certificate_management_policy`.\n"
                    },
                    "certificateManagementPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/ReservedDomainCertificateManagementPolicy:ReservedDomainCertificateManagementPolicy"
                        },
                        "description": "configuration for automatic management of TLS certificates for this domain, or null if automatic management is disabled\n"
                    },
                    "cnameTarget": {
                        "type": "string",
                        "description": "DNS CNAME target for a custom hostname, or null if the reserved domain is a subdomain of *.ngrok.io\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of what this reserved domain will be used for\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "hostname of the reserved domain\n",
                        "willReplaceOnChanges": true
                    },
                    "httpEndpointConfigurationId": {
                        "type": "string",
                        "description": "ID of an endpoint configuration of type http that will be used to handle inbound http traffic to this domain\n"
                    },
                    "httpsEndpointConfigurationId": {
                        "type": "string",
                        "description": "ID of an endpoint configuration of type https that will be used to handle inbound https traffic to this domain\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "the domain name to reserve. It may be a full domain name like app.example.com. If the name does not contain a '.' it will reserve that subdomain on ngrok.io.\n",
                        "willReplaceOnChanges": true
                    },
                    "region": {
                        "type": "string",
                        "description": "reserve the domain in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/sshCertificateAuthority:SshCertificateAuthority": {
            "description": "An SSH Certificate Authority is a pair of an SSH Certificate and its private\n key that can be used to sign other SSH host and user certificates.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/sshCertificateAuthority.SshCertificateAuthority(\"example\", {\n    description: \"Staging Environment Hosts\",\n    privateKeyType: \"ed25519\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.ssh_certificate_authority.SshCertificateAuthority(\"example\",\n    description=Staging Environment Hosts,\n    private_key_type=ed25519)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.SshCertificateAuthority.SshCertificateAuthority(\"example\", new()\n    {\n        Description = \"Staging Environment Hosts\",\n        PrivateKeyType = \"ed25519\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewSshCertificateAuthority(ctx, \"example\", \u0026ngrok.SshCertificateAuthorityArgs{\n\t\t\tDescription:    \"Staging Environment Hosts\",\n\t\t\tPrivateKeyType: \"ed25519\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.SshCertificateAuthority;\nimport com.pulumi.ngrok.SshCertificateAuthorityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new SshCertificateAuthority(\"example\", SshCertificateAuthorityArgs.builder()        \n            .description(\"Staging Environment Hosts\")\n            .privateKeyType(\"ed25519\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:SshCertificateAuthority\n    properties:\n      description: Staging Environment Hosts\n      privateKeyType: ed25519\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "human-readable description of this SSH Certificate Authority. optional, max 255 bytes.\n"
                },
                "ellipticCurve": {
                    "type": "string",
                    "description": "the type of elliptic curve to use when creating an ECDSA key\n"
                },
                "keySize": {
                    "type": "integer",
                    "description": "the key size to use when creating an RSA key. one of `2048` or `4096`\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "the type of private key for this SSH Certificate Authority\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "the type of private key to generate. one of `rsa`, `ecdsa`, `ed25519`\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "raw public key for this SSH Certificate Authority\n"
                }
            },
            "required": [
                "keyType",
                "publicKey"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "human-readable description of this SSH Certificate Authority. optional, max 255 bytes.\n"
                },
                "ellipticCurve": {
                    "type": "string",
                    "description": "the type of elliptic curve to use when creating an ECDSA key\n",
                    "willReplaceOnChanges": true
                },
                "keySize": {
                    "type": "integer",
                    "description": "the key size to use when creating an RSA key. one of `2048` or `4096`\n",
                    "willReplaceOnChanges": true
                },
                "keyType": {
                    "type": "string",
                    "description": "the type of private key for this SSH Certificate Authority\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.\n"
                },
                "privateKeyType": {
                    "type": "string",
                    "description": "the type of private key to generate. one of `rsa`, `ecdsa`, `ed25519`\n",
                    "willReplaceOnChanges": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "raw public key for this SSH Certificate Authority\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SshCertificateAuthority resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "human-readable description of this SSH Certificate Authority. optional, max 255 bytes.\n"
                    },
                    "ellipticCurve": {
                        "type": "string",
                        "description": "the type of elliptic curve to use when creating an ECDSA key\n",
                        "willReplaceOnChanges": true
                    },
                    "keySize": {
                        "type": "integer",
                        "description": "the key size to use when creating an RSA key. one of `2048` or `4096`\n",
                        "willReplaceOnChanges": true
                    },
                    "keyType": {
                        "type": "string",
                        "description": "the type of private key for this SSH Certificate Authority\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.\n"
                    },
                    "privateKeyType": {
                        "type": "string",
                        "description": "the type of private key to generate. one of `rsa`, `ecdsa`, `ed25519`\n",
                        "willReplaceOnChanges": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "raw public key for this SSH Certificate Authority\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/sshCredential:SshCredential": {
            "description": "SSH Credentials are SSH public keys that can be used to start SSH tunnels\n via the ngrok SSH tunnel gateway.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/sshCredential.SshCredential(\"example\", {\n    acls: [\n        \"bind:1.tcp.ngrok.io:20002\",\n        \"bind:132.devices.company.com\",\n    ],\n    description: \"for device #132\",\n    publicKey: \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDmGS49FkSODAcKhn3+/47DW2zEn19BZvzRQ8RZjL3v6hCIX2qXfsFK35EGxNI0wV23H4xXC2gVRPHKU71YnCb50tad3yMBTM6+2yfGsEDasEH/anmBLclChKvuGiT547RskZlpbAbdq3GvbzmY+R/2EBRMOiObpc8XmSzKAd05j28kqN0+rZO65SWId0MXdvJdSCSAnuRqBNd/aXKlu8hBPDcgwbT2lMkuR+ApoBS2FLRBOiQyt2Ol0T7Uuf7lTLlazpGB3uTw5zFYUNXkuuI6cAP8QYuY1Bne/hNrG8t3Aw9a1yc2C4Fz1hJ/4OMRxTQ8SUQf+Rmxs8DryMlMFJ8r device132@example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.ssh_credential.SshCredential(\"example\",\n    acls=[\n        bind:1.tcp.ngrok.io:20002,\n        bind:132.devices.company.com,\n    ],\n    description=for device #132,\n    public_key=ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDmGS49FkSODAcKhn3+/47DW2zEn19BZvzRQ8RZjL3v6hCIX2qXfsFK35EGxNI0wV23H4xXC2gVRPHKU71YnCb50tad3yMBTM6+2yfGsEDasEH/anmBLclChKvuGiT547RskZlpbAbdq3GvbzmY+R/2EBRMOiObpc8XmSzKAd05j28kqN0+rZO65SWId0MXdvJdSCSAnuRqBNd/aXKlu8hBPDcgwbT2lMkuR+ApoBS2FLRBOiQyt2Ol0T7Uuf7lTLlazpGB3uTw5zFYUNXkuuI6cAP8QYuY1Bne/hNrG8t3Aw9a1yc2C4Fz1hJ/4OMRxTQ8SUQf+Rmxs8DryMlMFJ8r device132@example.com)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.SshCredential.SshCredential(\"example\", new()\n    {\n        Acls = new[]\n        {\n            \"bind:1.tcp.ngrok.io:20002\",\n            \"bind:132.devices.company.com\",\n        },\n        Description = \"for device #132\",\n        PublicKey = \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDmGS49FkSODAcKhn3+/47DW2zEn19BZvzRQ8RZjL3v6hCIX2qXfsFK35EGxNI0wV23H4xXC2gVRPHKU71YnCb50tad3yMBTM6+2yfGsEDasEH/anmBLclChKvuGiT547RskZlpbAbdq3GvbzmY+R/2EBRMOiObpc8XmSzKAd05j28kqN0+rZO65SWId0MXdvJdSCSAnuRqBNd/aXKlu8hBPDcgwbT2lMkuR+ApoBS2FLRBOiQyt2Ol0T7Uuf7lTLlazpGB3uTw5zFYUNXkuuI6cAP8QYuY1Bne/hNrG8t3Aw9a1yc2C4Fz1hJ/4OMRxTQ8SUQf+Rmxs8DryMlMFJ8r device132@example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewSshCredential(ctx, \"example\", \u0026ngrok.SshCredentialArgs{\n\t\t\tAcls: []string{\n\t\t\t\t\"bind:1.tcp.ngrok.io:20002\",\n\t\t\t\t\"bind:132.devices.company.com\",\n\t\t\t},\n\t\t\tDescription: \"for device #132\",\n\t\t\tPublicKey:   \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDmGS49FkSODAcKhn3+/47DW2zEn19BZvzRQ8RZjL3v6hCIX2qXfsFK35EGxNI0wV23H4xXC2gVRPHKU71YnCb50tad3yMBTM6+2yfGsEDasEH/anmBLclChKvuGiT547RskZlpbAbdq3GvbzmY+R/2EBRMOiObpc8XmSzKAd05j28kqN0+rZO65SWId0MXdvJdSCSAnuRqBNd/aXKlu8hBPDcgwbT2lMkuR+ApoBS2FLRBOiQyt2Ol0T7Uuf7lTLlazpGB3uTw5zFYUNXkuuI6cAP8QYuY1Bne/hNrG8t3Aw9a1yc2C4Fz1hJ/4OMRxTQ8SUQf+Rmxs8DryMlMFJ8r device132@example.com\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.SshCredential;\nimport com.pulumi.ngrok.SshCredentialArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new SshCredential(\"example\", SshCredentialArgs.builder()        \n            .acls(            \n                \"bind:1.tcp.ngrok.io:20002\",\n                \"bind:132.devices.company.com\")\n            .description(\"for device #132\")\n            .publicKey(\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDmGS49FkSODAcKhn3+/47DW2zEn19BZvzRQ8RZjL3v6hCIX2qXfsFK35EGxNI0wV23H4xXC2gVRPHKU71YnCb50tad3yMBTM6+2yfGsEDasEH/anmBLclChKvuGiT547RskZlpbAbdq3GvbzmY+R/2EBRMOiObpc8XmSzKAd05j28kqN0+rZO65SWId0MXdvJdSCSAnuRqBNd/aXKlu8hBPDcgwbT2lMkuR+ApoBS2FLRBOiQyt2Ol0T7Uuf7lTLlazpGB3uTw5zFYUNXkuuI6cAP8QYuY1Bne/hNrG8t3Aw9a1yc2C4Fz1hJ/4OMRxTQ8SUQf+Rmxs8DryMlMFJ8r device132@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:SshCredential\n    properties:\n      acls:\n        - bind:1.tcp.ngrok.io:20002\n        - bind:132.devices.company.com\n      description: 'for device #132'\n      publicKey: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDmGS49FkSODAcKhn3+/47DW2zEn19BZvzRQ8RZjL3v6hCIX2qXfsFK35EGxNI0wV23H4xXC2gVRPHKU71YnCb50tad3yMBTM6+2yfGsEDasEH/anmBLclChKvuGiT547RskZlpbAbdq3GvbzmY+R/2EBRMOiObpc8XmSzKAd05j28kqN0+rZO65SWId0MXdvJdSCSAnuRqBNd/aXKlu8hBPDcgwbT2lMkuR+ApoBS2FLRBOiQyt2Ol0T7Uuf7lTLlazpGB3uTw5zFYUNXkuuI6cAP8QYuY1Bne/hNrG8t3Aw9a1yc2C4Fz1hJ/4OMRxTQ8SUQf+Rmxs8DryMlMFJ8r device132@example.com\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "acls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "the PEM-encoded public key of the SSH keypair that will be used to authenticate\n"
                }
            },
            "required": [
                "publicKey"
            ],
            "inputProperties": {
                "acls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "the PEM-encoded public key of the SSH keypair that will be used to authenticate\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "publicKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SshCredential resources.\n",
                "properties": {
                    "acls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains and addresses the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "the PEM-encoded public key of the SSH keypair that will be used to authenticate\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/sshHostCertificate:SshHostCertificate": {
            "description": "SSH Host Certificates along with the corresponding private key allows an SSH\n server to assert its authenticity to connecting SSH clients who trust the\n SSH Certificate Authority that was used to sign the certificate.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/sshHostCertificate.SshHostCertificate(\"example\", {\n    description: \"personal server\",\n    principals: [\n        \"inconshreveable.com\",\n        \"10.2.42.9\",\n    ],\n    publicKey: \"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= inconshreveable.com\",\n    sshCertificateAuthorityId: \"sshca_25auH7sr0BYJFNyfJUwXPzyyFAz\",\n    validUntil: \"2022-05-26T08:23:47Z\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.ssh_host_certificate.SshHostCertificate(\"example\",\n    description=personal server,\n    principals=[\n        inconshreveable.com,\n        10.2.42.9,\n    ],\n    public_key=ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= inconshreveable.com,\n    ssh_certificate_authority_id=sshca_25auH7sr0BYJFNyfJUwXPzyyFAz,\n    valid_until=2022-05-26T08:23:47Z)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.SshHostCertificate.SshHostCertificate(\"example\", new()\n    {\n        Description = \"personal server\",\n        Principals = new[]\n        {\n            \"inconshreveable.com\",\n            \"10.2.42.9\",\n        },\n        PublicKey = \"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= inconshreveable.com\",\n        SshCertificateAuthorityId = \"sshca_25auH7sr0BYJFNyfJUwXPzyyFAz\",\n        ValidUntil = \"2022-05-26T08:23:47Z\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewSshHostCertificate(ctx, \"example\", \u0026ngrok.SshHostCertificateArgs{\n\t\t\tDescription: \"personal server\",\n\t\t\tPrincipals: []string{\n\t\t\t\t\"inconshreveable.com\",\n\t\t\t\t\"10.2.42.9\",\n\t\t\t},\n\t\t\tPublicKey:                 \"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= inconshreveable.com\",\n\t\t\tSshCertificateAuthorityId: \"sshca_25auH7sr0BYJFNyfJUwXPzyyFAz\",\n\t\t\tValidUntil:                \"2022-05-26T08:23:47Z\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.SshHostCertificate;\nimport com.pulumi.ngrok.SshHostCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new SshHostCertificate(\"example\", SshHostCertificateArgs.builder()        \n            .description(\"personal server\")\n            .principals(            \n                \"inconshreveable.com\",\n                \"10.2.42.9\")\n            .publicKey(\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= inconshreveable.com\")\n            .sshCertificateAuthorityId(\"sshca_25auH7sr0BYJFNyfJUwXPzyyFAz\")\n            .validUntil(\"2022-05-26T08:23:47Z\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:SshHostCertificate\n    properties:\n      description: personal server\n      principals:\n        - inconshreveable.com\n        - 10.2.42.9\n      publicKey: ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= inconshreveable.com\n      sshCertificateAuthorityId: sshca_25auH7sr0BYJFNyfJUwXPzyyFAz\n      validUntil: 2022-05-26T08:23:47Z\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "the signed SSH certificate in OpenSSH Authorized Keys format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of this SSH Host Certificate. optional, max 255 bytes.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.\n"
                },
                "principals": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "the list of principals included in the ssh host certificate. This is the list of hostnames and/or IP addresses that are authorized to serve SSH traffic with this certificate. Dangerously, if no principals are specified, this certificate is considered valid for all hosts.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "a public key in OpenSSH Authorized Keys format that this certificate signs\n"
                },
                "sshCertificateAuthorityId": {
                    "type": "string",
                    "description": "the ssh certificate authority that is used to sign this ssh host certificate\n"
                },
                "validAfter": {
                    "type": "string",
                    "description": "the time when the ssh host certificate becomes valid, in RFC 3339 format.\n"
                },
                "validUntil": {
                    "type": "string",
                    "description": "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.\n"
                }
            },
            "required": [
                "certificate",
                "keyType",
                "publicKey",
                "sshCertificateAuthorityId"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "string",
                    "description": "the signed SSH certificate in OpenSSH Authorized Keys format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of this SSH Host Certificate. optional, max 255 bytes.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.\n"
                },
                "principals": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "the list of principals included in the ssh host certificate. This is the list of hostnames and/or IP addresses that are authorized to serve SSH traffic with this certificate. Dangerously, if no principals are specified, this certificate is considered valid for all hosts.\n",
                    "willReplaceOnChanges": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "a public key in OpenSSH Authorized Keys format that this certificate signs\n",
                    "willReplaceOnChanges": true
                },
                "sshCertificateAuthorityId": {
                    "type": "string",
                    "description": "the ssh certificate authority that is used to sign this ssh host certificate\n",
                    "willReplaceOnChanges": true
                },
                "validAfter": {
                    "type": "string",
                    "description": "the time when the ssh host certificate becomes valid, in RFC 3339 format.\n",
                    "willReplaceOnChanges": true
                },
                "validUntil": {
                    "type": "string",
                    "description": "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "publicKey",
                "sshCertificateAuthorityId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SshHostCertificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "the signed SSH certificate in OpenSSH Authorized Keys format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of this SSH Host Certificate. optional, max 255 bytes.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.\n"
                    },
                    "principals": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "the list of principals included in the ssh host certificate. This is the list of hostnames and/or IP addresses that are authorized to serve SSH traffic with this certificate. Dangerously, if no principals are specified, this certificate is considered valid for all hosts.\n",
                        "willReplaceOnChanges": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "a public key in OpenSSH Authorized Keys format that this certificate signs\n",
                        "willReplaceOnChanges": true
                    },
                    "sshCertificateAuthorityId": {
                        "type": "string",
                        "description": "the ssh certificate authority that is used to sign this ssh host certificate\n",
                        "willReplaceOnChanges": true
                    },
                    "validAfter": {
                        "type": "string",
                        "description": "the time when the ssh host certificate becomes valid, in RFC 3339 format.\n",
                        "willReplaceOnChanges": true
                    },
                    "validUntil": {
                        "type": "string",
                        "description": "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/sshUserCertificate:SshUserCertificate": {
            "description": "SSH User Certificates are presented by SSH clients when connecting to an SSH\n server to authenticate their connection. The SSH server must trust the SSH\n Certificate Authority used to sign the certificate.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/sshUserCertificate.SshUserCertificate(\"example\", {\n    description: \"temporary access to staging machine\",\n    principals: [\n        \"ec2-user\",\n        \"root\",\n    ],\n    publicKey: \"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK58lFzmWlDimDtBz78wVT4oauA8PjY0CiXTCEIsBNC6UwOJvZ0jdSaYNhDaa7dRV84DfBb/gKzqlXC7cVMZjl0= alan@work-laptop\",\n    sshCertificateAuthorityId: \"sshca_25auH5JtiUPW9eMiXYzujvcpkGW\",\n    validUntil: \"2022-05-26T08:23:47Z\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.ssh_user_certificate.SshUserCertificate(\"example\",\n    description=temporary access to staging machine,\n    principals=[\n        ec2-user,\n        root,\n    ],\n    public_key=ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK58lFzmWlDimDtBz78wVT4oauA8PjY0CiXTCEIsBNC6UwOJvZ0jdSaYNhDaa7dRV84DfBb/gKzqlXC7cVMZjl0= alan@work-laptop,\n    ssh_certificate_authority_id=sshca_25auH5JtiUPW9eMiXYzujvcpkGW,\n    valid_until=2022-05-26T08:23:47Z)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.SshUserCertificate.SshUserCertificate(\"example\", new()\n    {\n        Description = \"temporary access to staging machine\",\n        Principals = new[]\n        {\n            \"ec2-user\",\n            \"root\",\n        },\n        PublicKey = \"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK58lFzmWlDimDtBz78wVT4oauA8PjY0CiXTCEIsBNC6UwOJvZ0jdSaYNhDaa7dRV84DfBb/gKzqlXC7cVMZjl0= alan@work-laptop\",\n        SshCertificateAuthorityId = \"sshca_25auH5JtiUPW9eMiXYzujvcpkGW\",\n        ValidUntil = \"2022-05-26T08:23:47Z\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewSshUserCertificate(ctx, \"example\", \u0026ngrok.SshUserCertificateArgs{\n\t\t\tDescription: \"temporary access to staging machine\",\n\t\t\tPrincipals: []string{\n\t\t\t\t\"ec2-user\",\n\t\t\t\t\"root\",\n\t\t\t},\n\t\t\tPublicKey:                 \"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK58lFzmWlDimDtBz78wVT4oauA8PjY0CiXTCEIsBNC6UwOJvZ0jdSaYNhDaa7dRV84DfBb/gKzqlXC7cVMZjl0= alan@work-laptop\",\n\t\t\tSshCertificateAuthorityId: \"sshca_25auH5JtiUPW9eMiXYzujvcpkGW\",\n\t\t\tValidUntil:                \"2022-05-26T08:23:47Z\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.SshUserCertificate;\nimport com.pulumi.ngrok.SshUserCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new SshUserCertificate(\"example\", SshUserCertificateArgs.builder()        \n            .description(\"temporary access to staging machine\")\n            .principals(            \n                \"ec2-user\",\n                \"root\")\n            .publicKey(\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK58lFzmWlDimDtBz78wVT4oauA8PjY0CiXTCEIsBNC6UwOJvZ0jdSaYNhDaa7dRV84DfBb/gKzqlXC7cVMZjl0= alan@work-laptop\")\n            .sshCertificateAuthorityId(\"sshca_25auH5JtiUPW9eMiXYzujvcpkGW\")\n            .validUntil(\"2022-05-26T08:23:47Z\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:SshUserCertificate\n    properties:\n      description: temporary access to staging machine\n      principals:\n        - ec2-user\n        - root\n      publicKey: ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK58lFzmWlDimDtBz78wVT4oauA8PjY0CiXTCEIsBNC6UwOJvZ0jdSaYNhDaa7dRV84DfBb/gKzqlXC7cVMZjl0= alan@work-laptop\n      sshCertificateAuthorityId: sshca_25auH5JtiUPW9eMiXYzujvcpkGW\n      validUntil: 2022-05-26T08:23:47Z\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive\n"
                },
                "criticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of this SSH User Certificate. optional, max 255 bytes.\n"
                },
                "extensions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{\"permit-pty\": \"\", \"permit-user-rc\": \"\"}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.\n"
                },
                "principals": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizinig the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "a public key in OpenSSH Authorized Keys format that this certificate signs\n"
                },
                "sshCertificateAuthorityId": {
                    "type": "string",
                    "description": "the ssh certificate authority that is used to sign this ssh user certificate\n"
                },
                "validAfter": {
                    "type": "string",
                    "description": "the time when the ssh host certificate becomes valid, in RFC 3339 format.\n"
                },
                "validUntil": {
                    "type": "string",
                    "description": "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.\n"
                }
            },
            "required": [
                "certificate",
                "keyType",
                "publicKey",
                "sshCertificateAuthorityId"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "string",
                    "description": "the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive\n",
                    "willReplaceOnChanges": true
                },
                "criticalOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of this SSH User Certificate. optional, max 255 bytes.\n"
                },
                "extensions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{\"permit-pty\": \"\", \"permit-user-rc\": \"\"}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.\n",
                    "willReplaceOnChanges": true
                },
                "keyType": {
                    "type": "string",
                    "description": "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.\n"
                },
                "principals": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizinig the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.\n",
                    "willReplaceOnChanges": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "a public key in OpenSSH Authorized Keys format that this certificate signs\n",
                    "willReplaceOnChanges": true
                },
                "sshCertificateAuthorityId": {
                    "type": "string",
                    "description": "the ssh certificate authority that is used to sign this ssh user certificate\n",
                    "willReplaceOnChanges": true
                },
                "validAfter": {
                    "type": "string",
                    "description": "the time when the ssh host certificate becomes valid, in RFC 3339 format.\n",
                    "willReplaceOnChanges": true
                },
                "validUntil": {
                    "type": "string",
                    "description": "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "publicKey",
                "sshCertificateAuthorityId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SshUserCertificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive\n",
                        "willReplaceOnChanges": true
                    },
                    "criticalOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of this SSH User Certificate. optional, max 255 bytes.\n"
                    },
                    "extensions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{\"permit-pty\": \"\", \"permit-user-rc\": \"\"}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.\n",
                        "willReplaceOnChanges": true
                    },
                    "keyType": {
                        "type": "string",
                        "description": "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.\n"
                    },
                    "principals": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizinig the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.\n",
                        "willReplaceOnChanges": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "a public key in OpenSSH Authorized Keys format that this certificate signs\n",
                        "willReplaceOnChanges": true
                    },
                    "sshCertificateAuthorityId": {
                        "type": "string",
                        "description": "the ssh certificate authority that is used to sign this ssh user certificate\n",
                        "willReplaceOnChanges": true
                    },
                    "validAfter": {
                        "type": "string",
                        "description": "the time when the ssh host certificate becomes valid, in RFC 3339 format.\n",
                        "willReplaceOnChanges": true
                    },
                    "validUntil": {
                        "type": "string",
                        "description": "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ngrok:index/tlsCertificate:TlsCertificate": {
            "description": "TLS Certificates are pairs of x509 certificates and their matching private\n key that can be used to terminate TLS traffic. TLS certificates are unused\n until they are attached to a Domain. TLS Certificates may also be\n provisioned by ngrok automatically for domains on which you have enabled\n automated certificate provisioning.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ngrok from \"@pulumi/ngrok\";\n\nconst example = new ngrok.index/tlsCertificate.TlsCertificate(\"example\", {\n    certificatePem: `-----BEGIN CERTIFICATE-----\nMIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\nNDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\nGANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\nAl8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\nLW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\nrQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\nVR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\nzCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\nAC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\ntOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\noGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\nd6JTpFbsCtwDjP23UEi7SZo=\n-----END CERTIFICATE-----\n`,\n    privateKeyPem: `-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDylZJCmDZd3fXK\nq8+LSBZcLKIRA+VuMtXXAYscuBgDRRZ8ON53NsD8isGF7piaiSBa3FvzZFGS9O23\nfnaLupk+hof822k1vdSJERD1y+29yn1buF5BaLFV6VrNFOqOBq2fNQi4igViPh9N\n8f4o+TkoidZe9aai3kySzsnQEQJfJKae2sXh1OFGw6wGZFuUp7mU4yCsFYNFDbAY\nNcjX1DrtVGodwWGqj4EIrQtGIC1vjVBrv0/dW5A+7S7FSJ5EF3kBnVwQKjsnHye8\nI/DpSKcrl405xhQNIs1Zm0MOX60J2dIHhsoS2pr8/RnHe5iJQ//vwBDfS4bfNrQD\nsyhvfPzvAgMBAAECggEBALLv7YE98exvi5zB+0fMFuJK8gkHDLequ93q/4hhqyTO\nU3WyJTdepiAi4fk/NEXZnIopPZJdj2aNUMQnfp43OE7MwYac+hBwRFQOyKnmkSmM\nMcf0SWKKLTUn+piIMzQsbOmhHxuwg6QiGslOFaJ3o9fpRL2rCg3dWDJ6Ypcd1NgE\nK0uy7gg+DwIpU6MeG6lA+HbxbGi+yd2x88Gjn9dGr7FZK34RUDooH60BCX9P8N9X\nT+n10MzzX7ZQOsLfe8FKc1/X8AybI5SYm1GMyfKD4QBt6JG4HKAjPHzBzcIpfN3d\n7BM11Imkrz7LcbUG+F23NVsi6n5IIGT1WqwCRIH2PpECgYEA/SJ5Ra4d0hUS5RYB\nzABquM3sp7JsKxCn7O5PqNLB4TgH9dXtWFhaFVB6juMGyHbvktVH0j4lps/Te0rk\nVU2zU1XxvCTFhtcCYUtNk0cRw6LH8feKiorXHdDRB33t0c47QSD/6AGOjBtxqD7B\n3ZxyR3P+7RdQopLLRFN+FHAnmzsCgYEA9VSGZDFSK+fbg4CgwkWdzuHrAXaUEv0U\novqqWd/yXB9wauEvRHnOrSgW6hFZQiatJOXx0KnalJQzohz/SLGO0MqGtwQbYWVT\nWiJgjUbNeiPEHBeUA6U55lVQr26kQSUWdXEtRbDz+hqV1K+6tTEMzaSPmJiHNgki\nlNMO2gqGQd0CgYBJ268qx5zn2UJEGWG41j5NYbg1TfgFsLxugzI2/heX0TNxZVP1\nPQI7ydmYq2ElSJ6qZxSnoX5255i7FqT8xskV/bOkw83mhAGrxb8Cw+/I90wDq8h+\nl/ggOPdkijfDybq8TBae6SVgd/l3r6f9M1KcypmNMApVBSPN8daNvBOyVQKBgQDo\nsj2utyFrx8Xsm4rf+kxOuPbBMooM4MQ8OmpuSP6G5sMofWLqHmcs0sO5TK9PEYRV\nZU3ST+ml2FSJRdvWRaRi4laZLWoTHZrL+aN/HVM0sMwIoUyhkIy0ruOTIuzlZZpB\n1xHL8qXX6nOHgw8jYdz1CUuyv6owVMXaR77kjer+eQKBgByYZlR/eNTzlot0SdFl\nIbgQ9bV7VLIo+vKzOXE3trfzRJMgUosLTp+5wdSVSW/VBdYZ7Ir3n0bbpY/dGinI\nVShxPbChhCZnhvG2lEEiekI44m5jHSA6hhtRdt/CrhL65Rw2SE5lMEe8htg1UGus\nwzLHWHBl72FjbjdhvEgrq60W\n-----END PRIVATE KEY-----\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_ngrok as ngrok\n\nexample = ngrok.index.tls_certificate.TlsCertificate(\"example\",\n    certificate_pem=-----BEGIN CERTIFICATE-----\nMIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\nNDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\nGANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\nAl8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\nLW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\nrQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\nVR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\nzCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\nAC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\ntOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\noGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\nd6JTpFbsCtwDjP23UEi7SZo=\n-----END CERTIFICATE-----\n,\n    private_key_pem=-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDylZJCmDZd3fXK\nq8+LSBZcLKIRA+VuMtXXAYscuBgDRRZ8ON53NsD8isGF7piaiSBa3FvzZFGS9O23\nfnaLupk+hof822k1vdSJERD1y+29yn1buF5BaLFV6VrNFOqOBq2fNQi4igViPh9N\n8f4o+TkoidZe9aai3kySzsnQEQJfJKae2sXh1OFGw6wGZFuUp7mU4yCsFYNFDbAY\nNcjX1DrtVGodwWGqj4EIrQtGIC1vjVBrv0/dW5A+7S7FSJ5EF3kBnVwQKjsnHye8\nI/DpSKcrl405xhQNIs1Zm0MOX60J2dIHhsoS2pr8/RnHe5iJQ//vwBDfS4bfNrQD\nsyhvfPzvAgMBAAECggEBALLv7YE98exvi5zB+0fMFuJK8gkHDLequ93q/4hhqyTO\nU3WyJTdepiAi4fk/NEXZnIopPZJdj2aNUMQnfp43OE7MwYac+hBwRFQOyKnmkSmM\nMcf0SWKKLTUn+piIMzQsbOmhHxuwg6QiGslOFaJ3o9fpRL2rCg3dWDJ6Ypcd1NgE\nK0uy7gg+DwIpU6MeG6lA+HbxbGi+yd2x88Gjn9dGr7FZK34RUDooH60BCX9P8N9X\nT+n10MzzX7ZQOsLfe8FKc1/X8AybI5SYm1GMyfKD4QBt6JG4HKAjPHzBzcIpfN3d\n7BM11Imkrz7LcbUG+F23NVsi6n5IIGT1WqwCRIH2PpECgYEA/SJ5Ra4d0hUS5RYB\nzABquM3sp7JsKxCn7O5PqNLB4TgH9dXtWFhaFVB6juMGyHbvktVH0j4lps/Te0rk\nVU2zU1XxvCTFhtcCYUtNk0cRw6LH8feKiorXHdDRB33t0c47QSD/6AGOjBtxqD7B\n3ZxyR3P+7RdQopLLRFN+FHAnmzsCgYEA9VSGZDFSK+fbg4CgwkWdzuHrAXaUEv0U\novqqWd/yXB9wauEvRHnOrSgW6hFZQiatJOXx0KnalJQzohz/SLGO0MqGtwQbYWVT\nWiJgjUbNeiPEHBeUA6U55lVQr26kQSUWdXEtRbDz+hqV1K+6tTEMzaSPmJiHNgki\nlNMO2gqGQd0CgYBJ268qx5zn2UJEGWG41j5NYbg1TfgFsLxugzI2/heX0TNxZVP1\nPQI7ydmYq2ElSJ6qZxSnoX5255i7FqT8xskV/bOkw83mhAGrxb8Cw+/I90wDq8h+\nl/ggOPdkijfDybq8TBae6SVgd/l3r6f9M1KcypmNMApVBSPN8daNvBOyVQKBgQDo\nsj2utyFrx8Xsm4rf+kxOuPbBMooM4MQ8OmpuSP6G5sMofWLqHmcs0sO5TK9PEYRV\nZU3ST+ml2FSJRdvWRaRi4laZLWoTHZrL+aN/HVM0sMwIoUyhkIy0ruOTIuzlZZpB\n1xHL8qXX6nOHgw8jYdz1CUuyv6owVMXaR77kjer+eQKBgByYZlR/eNTzlot0SdFl\nIbgQ9bV7VLIo+vKzOXE3trfzRJMgUosLTp+5wdSVSW/VBdYZ7Ir3n0bbpY/dGinI\nVShxPbChhCZnhvG2lEEiekI44m5jHSA6hhtRdt/CrhL65Rw2SE5lMEe8htg1UGus\nwzLHWHBl72FjbjdhvEgrq60W\n-----END PRIVATE KEY-----\n)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ngrok = Pulumi.Ngrok;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ngrok.Index.TlsCertificate.TlsCertificate(\"example\", new()\n    {\n        CertificatePem = @\"-----BEGIN CERTIFICATE-----\nMIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\nNDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\nGANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\nAl8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\nLW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\nrQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\nVR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\nzCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\nAC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\ntOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\noGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\nd6JTpFbsCtwDjP23UEi7SZo=\n-----END CERTIFICATE-----\n\",\n        PrivateKeyPem = @\"-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDylZJCmDZd3fXK\nq8+LSBZcLKIRA+VuMtXXAYscuBgDRRZ8ON53NsD8isGF7piaiSBa3FvzZFGS9O23\nfnaLupk+hof822k1vdSJERD1y+29yn1buF5BaLFV6VrNFOqOBq2fNQi4igViPh9N\n8f4o+TkoidZe9aai3kySzsnQEQJfJKae2sXh1OFGw6wGZFuUp7mU4yCsFYNFDbAY\nNcjX1DrtVGodwWGqj4EIrQtGIC1vjVBrv0/dW5A+7S7FSJ5EF3kBnVwQKjsnHye8\nI/DpSKcrl405xhQNIs1Zm0MOX60J2dIHhsoS2pr8/RnHe5iJQ//vwBDfS4bfNrQD\nsyhvfPzvAgMBAAECggEBALLv7YE98exvi5zB+0fMFuJK8gkHDLequ93q/4hhqyTO\nU3WyJTdepiAi4fk/NEXZnIopPZJdj2aNUMQnfp43OE7MwYac+hBwRFQOyKnmkSmM\nMcf0SWKKLTUn+piIMzQsbOmhHxuwg6QiGslOFaJ3o9fpRL2rCg3dWDJ6Ypcd1NgE\nK0uy7gg+DwIpU6MeG6lA+HbxbGi+yd2x88Gjn9dGr7FZK34RUDooH60BCX9P8N9X\nT+n10MzzX7ZQOsLfe8FKc1/X8AybI5SYm1GMyfKD4QBt6JG4HKAjPHzBzcIpfN3d\n7BM11Imkrz7LcbUG+F23NVsi6n5IIGT1WqwCRIH2PpECgYEA/SJ5Ra4d0hUS5RYB\nzABquM3sp7JsKxCn7O5PqNLB4TgH9dXtWFhaFVB6juMGyHbvktVH0j4lps/Te0rk\nVU2zU1XxvCTFhtcCYUtNk0cRw6LH8feKiorXHdDRB33t0c47QSD/6AGOjBtxqD7B\n3ZxyR3P+7RdQopLLRFN+FHAnmzsCgYEA9VSGZDFSK+fbg4CgwkWdzuHrAXaUEv0U\novqqWd/yXB9wauEvRHnOrSgW6hFZQiatJOXx0KnalJQzohz/SLGO0MqGtwQbYWVT\nWiJgjUbNeiPEHBeUA6U55lVQr26kQSUWdXEtRbDz+hqV1K+6tTEMzaSPmJiHNgki\nlNMO2gqGQd0CgYBJ268qx5zn2UJEGWG41j5NYbg1TfgFsLxugzI2/heX0TNxZVP1\nPQI7ydmYq2ElSJ6qZxSnoX5255i7FqT8xskV/bOkw83mhAGrxb8Cw+/I90wDq8h+\nl/ggOPdkijfDybq8TBae6SVgd/l3r6f9M1KcypmNMApVBSPN8daNvBOyVQKBgQDo\nsj2utyFrx8Xsm4rf+kxOuPbBMooM4MQ8OmpuSP6G5sMofWLqHmcs0sO5TK9PEYRV\nZU3ST+ml2FSJRdvWRaRi4laZLWoTHZrL+aN/HVM0sMwIoUyhkIy0ruOTIuzlZZpB\n1xHL8qXX6nOHgw8jYdz1CUuyv6owVMXaR77kjer+eQKBgByYZlR/eNTzlot0SdFl\nIbgQ9bV7VLIo+vKzOXE3trfzRJMgUosLTp+5wdSVSW/VBdYZ7Ir3n0bbpY/dGinI\nVShxPbChhCZnhvG2lEEiekI44m5jHSA6hhtRdt/CrhL65Rw2SE5lMEe8htg1UGus\nwzLHWHBl72FjbjdhvEgrq60W\n-----END PRIVATE KEY-----\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-ngrok/sdk/v1/go/ngrok\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ngrok.NewTlsCertificate(ctx, \"example\", \u0026ngrok.TlsCertificateArgs{\n\t\t\tCertificatePem: `-----BEGIN CERTIFICATE-----\nMIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\nNDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\nGANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\nAl8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\nLW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\nrQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\nVR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\nzCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\nAC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\ntOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\noGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\nd6JTpFbsCtwDjP23UEi7SZo=\n-----END CERTIFICATE-----\n`,\n\t\t\tPrivateKeyPem: `-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDylZJCmDZd3fXK\nq8+LSBZcLKIRA+VuMtXXAYscuBgDRRZ8ON53NsD8isGF7piaiSBa3FvzZFGS9O23\nfnaLupk+hof822k1vdSJERD1y+29yn1buF5BaLFV6VrNFOqOBq2fNQi4igViPh9N\n8f4o+TkoidZe9aai3kySzsnQEQJfJKae2sXh1OFGw6wGZFuUp7mU4yCsFYNFDbAY\nNcjX1DrtVGodwWGqj4EIrQtGIC1vjVBrv0/dW5A+7S7FSJ5EF3kBnVwQKjsnHye8\nI/DpSKcrl405xhQNIs1Zm0MOX60J2dIHhsoS2pr8/RnHe5iJQ//vwBDfS4bfNrQD\nsyhvfPzvAgMBAAECggEBALLv7YE98exvi5zB+0fMFuJK8gkHDLequ93q/4hhqyTO\nU3WyJTdepiAi4fk/NEXZnIopPZJdj2aNUMQnfp43OE7MwYac+hBwRFQOyKnmkSmM\nMcf0SWKKLTUn+piIMzQsbOmhHxuwg6QiGslOFaJ3o9fpRL2rCg3dWDJ6Ypcd1NgE\nK0uy7gg+DwIpU6MeG6lA+HbxbGi+yd2x88Gjn9dGr7FZK34RUDooH60BCX9P8N9X\nT+n10MzzX7ZQOsLfe8FKc1/X8AybI5SYm1GMyfKD4QBt6JG4HKAjPHzBzcIpfN3d\n7BM11Imkrz7LcbUG+F23NVsi6n5IIGT1WqwCRIH2PpECgYEA/SJ5Ra4d0hUS5RYB\nzABquM3sp7JsKxCn7O5PqNLB4TgH9dXtWFhaFVB6juMGyHbvktVH0j4lps/Te0rk\nVU2zU1XxvCTFhtcCYUtNk0cRw6LH8feKiorXHdDRB33t0c47QSD/6AGOjBtxqD7B\n3ZxyR3P+7RdQopLLRFN+FHAnmzsCgYEA9VSGZDFSK+fbg4CgwkWdzuHrAXaUEv0U\novqqWd/yXB9wauEvRHnOrSgW6hFZQiatJOXx0KnalJQzohz/SLGO0MqGtwQbYWVT\nWiJgjUbNeiPEHBeUA6U55lVQr26kQSUWdXEtRbDz+hqV1K+6tTEMzaSPmJiHNgki\nlNMO2gqGQd0CgYBJ268qx5zn2UJEGWG41j5NYbg1TfgFsLxugzI2/heX0TNxZVP1\nPQI7ydmYq2ElSJ6qZxSnoX5255i7FqT8xskV/bOkw83mhAGrxb8Cw+/I90wDq8h+\nl/ggOPdkijfDybq8TBae6SVgd/l3r6f9M1KcypmNMApVBSPN8daNvBOyVQKBgQDo\nsj2utyFrx8Xsm4rf+kxOuPbBMooM4MQ8OmpuSP6G5sMofWLqHmcs0sO5TK9PEYRV\nZU3ST+ml2FSJRdvWRaRi4laZLWoTHZrL+aN/HVM0sMwIoUyhkIy0ruOTIuzlZZpB\n1xHL8qXX6nOHgw8jYdz1CUuyv6owVMXaR77kjer+eQKBgByYZlR/eNTzlot0SdFl\nIbgQ9bV7VLIo+vKzOXE3trfzRJMgUosLTp+5wdSVSW/VBdYZ7Ir3n0bbpY/dGinI\nVShxPbChhCZnhvG2lEEiekI44m5jHSA6hhtRdt/CrhL65Rw2SE5lMEe8htg1UGus\nwzLHWHBl72FjbjdhvEgrq60W\n-----END PRIVATE KEY-----\n`,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ngrok.TlsCertificate;\nimport com.pulumi.ngrok.TlsCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TlsCertificate(\"example\", TlsCertificateArgs.builder()        \n            .certificatePem(\"\"\"\n-----BEGIN CERTIFICATE-----\nMIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\nBQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\nNDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\nGANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\nAl8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\nLW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\nrQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\nVR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\nzCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\nAC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\ntOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\noGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\nd6JTpFbsCtwDjP23UEi7SZo=\n-----END CERTIFICATE-----\n            \"\"\")\n            .privateKeyPem(\"\"\"\n-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDylZJCmDZd3fXK\nq8+LSBZcLKIRA+VuMtXXAYscuBgDRRZ8ON53NsD8isGF7piaiSBa3FvzZFGS9O23\nfnaLupk+hof822k1vdSJERD1y+29yn1buF5BaLFV6VrNFOqOBq2fNQi4igViPh9N\n8f4o+TkoidZe9aai3kySzsnQEQJfJKae2sXh1OFGw6wGZFuUp7mU4yCsFYNFDbAY\nNcjX1DrtVGodwWGqj4EIrQtGIC1vjVBrv0/dW5A+7S7FSJ5EF3kBnVwQKjsnHye8\nI/DpSKcrl405xhQNIs1Zm0MOX60J2dIHhsoS2pr8/RnHe5iJQ//vwBDfS4bfNrQD\nsyhvfPzvAgMBAAECggEBALLv7YE98exvi5zB+0fMFuJK8gkHDLequ93q/4hhqyTO\nU3WyJTdepiAi4fk/NEXZnIopPZJdj2aNUMQnfp43OE7MwYac+hBwRFQOyKnmkSmM\nMcf0SWKKLTUn+piIMzQsbOmhHxuwg6QiGslOFaJ3o9fpRL2rCg3dWDJ6Ypcd1NgE\nK0uy7gg+DwIpU6MeG6lA+HbxbGi+yd2x88Gjn9dGr7FZK34RUDooH60BCX9P8N9X\nT+n10MzzX7ZQOsLfe8FKc1/X8AybI5SYm1GMyfKD4QBt6JG4HKAjPHzBzcIpfN3d\n7BM11Imkrz7LcbUG+F23NVsi6n5IIGT1WqwCRIH2PpECgYEA/SJ5Ra4d0hUS5RYB\nzABquM3sp7JsKxCn7O5PqNLB4TgH9dXtWFhaFVB6juMGyHbvktVH0j4lps/Te0rk\nVU2zU1XxvCTFhtcCYUtNk0cRw6LH8feKiorXHdDRB33t0c47QSD/6AGOjBtxqD7B\n3ZxyR3P+7RdQopLLRFN+FHAnmzsCgYEA9VSGZDFSK+fbg4CgwkWdzuHrAXaUEv0U\novqqWd/yXB9wauEvRHnOrSgW6hFZQiatJOXx0KnalJQzohz/SLGO0MqGtwQbYWVT\nWiJgjUbNeiPEHBeUA6U55lVQr26kQSUWdXEtRbDz+hqV1K+6tTEMzaSPmJiHNgki\nlNMO2gqGQd0CgYBJ268qx5zn2UJEGWG41j5NYbg1TfgFsLxugzI2/heX0TNxZVP1\nPQI7ydmYq2ElSJ6qZxSnoX5255i7FqT8xskV/bOkw83mhAGrxb8Cw+/I90wDq8h+\nl/ggOPdkijfDybq8TBae6SVgd/l3r6f9M1KcypmNMApVBSPN8daNvBOyVQKBgQDo\nsj2utyFrx8Xsm4rf+kxOuPbBMooM4MQ8OmpuSP6G5sMofWLqHmcs0sO5TK9PEYRV\nZU3ST+ml2FSJRdvWRaRi4laZLWoTHZrL+aN/HVM0sMwIoUyhkIy0ruOTIuzlZZpB\n1xHL8qXX6nOHgw8jYdz1CUuyv6owVMXaR77kjer+eQKBgByYZlR/eNTzlot0SdFl\nIbgQ9bV7VLIo+vKzOXE3trfzRJMgUosLTp+5wdSVSW/VBdYZ7Ir3n0bbpY/dGinI\nVShxPbChhCZnhvG2lEEiekI44m5jHSA6hhtRdt/CrhL65Rw2SE5lMEe8htg1UGus\nwzLHWHBl72FjbjdhvEgrq60W\n-----END PRIVATE KEY-----\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ngrok:TlsCertificate\n    properties:\n      certificatePem: |\n        -----BEGIN CERTIFICATE-----\n        MIIDDTCCAfWgAwIBAgIUBUunDdA4gjgtEbZA8w9Ljhvl3bEwDQYJKoZIhvcNAQEL\n        BQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjAwMzI0MTgxODE5WhcNMjAw\n        NDIzMTgxODE5WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN\n        AQEBBQADggEPADCCAQoCggEBAPKVkkKYNl3d9cqrz4tIFlwsohED5W4y1dcBixy4\n        GANFFnw43nc2wPyKwYXumJqJIFrcW/NkUZL07bd+dou6mT6Gh/zbaTW91IkREPXL\n        7b3KfVu4XkFosVXpWs0U6o4GrZ81CLiKBWI+H03x/ij5OSiJ1l71pqLeTJLOydAR\n        Al8kpp7axeHU4UbDrAZkW5SnuZTjIKwVg0UNsBg1yNfUOu1Uah3BYaqPgQitC0Yg\n        LW+NUGu/T91bkD7tLsVInkQXeQGdXBAqOycfJ7wj8OlIpyuXjTnGFA0izVmbQw5f\n        rQnZ0geGyhLamvz9Gcd7mIlD/+/AEN9Lht82tAOzKG98/O8CAwEAAaNTMFEwHQYD\n        VR0OBBYEFKv6RsvEC6T+zCtJZwB0FCR1sEkhMB8GA1UdIwQYMBaAFKv6RsvEC6T+\n        zCtJZwB0FCR1sEkhMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\n        AC5fBrouinespo5+9AipjhY/HOKTg+OCnppFnSnqeU1eXZZJ0oakdHTpTNxtbQP9\n        tOJTA2f3KWvmpNDMohEQXZz8wHDkdbrIXJKVp6zs1pEp+0BIjA4y9mSywa5xuyk0\n        oGeChRgGqp2JujDyPCb7LEaKKQEEdMqy73QG+jEAh14+wKixlAf1nATBdeCUvssK\n        2x1uZMyqjJFB5y/5EdnWQzD4WJkrsCkxsZHVMN1d+dqf2sf3dTRV8fzsFGOG17NS\n        6u2n9iGcFdBA82XN8yeLIWhy1t3GWutG1sdxENbFRRXea+iUqzDsmRtkaBma2GLQ\n        d6JTpFbsCtwDjP23UEi7SZo=\n        -----END CERTIFICATE-----\n      privateKeyPem: |\n        -----BEGIN PRIVATE KEY-----\n        MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDylZJCmDZd3fXK\n        q8+LSBZcLKIRA+VuMtXXAYscuBgDRRZ8ON53NsD8isGF7piaiSBa3FvzZFGS9O23\n        fnaLupk+hof822k1vdSJERD1y+29yn1buF5BaLFV6VrNFOqOBq2fNQi4igViPh9N\n        8f4o+TkoidZe9aai3kySzsnQEQJfJKae2sXh1OFGw6wGZFuUp7mU4yCsFYNFDbAY\n        NcjX1DrtVGodwWGqj4EIrQtGIC1vjVBrv0/dW5A+7S7FSJ5EF3kBnVwQKjsnHye8\n        I/DpSKcrl405xhQNIs1Zm0MOX60J2dIHhsoS2pr8/RnHe5iJQ//vwBDfS4bfNrQD\n        syhvfPzvAgMBAAECggEBALLv7YE98exvi5zB+0fMFuJK8gkHDLequ93q/4hhqyTO\n        U3WyJTdepiAi4fk/NEXZnIopPZJdj2aNUMQnfp43OE7MwYac+hBwRFQOyKnmkSmM\n        Mcf0SWKKLTUn+piIMzQsbOmhHxuwg6QiGslOFaJ3o9fpRL2rCg3dWDJ6Ypcd1NgE\n        K0uy7gg+DwIpU6MeG6lA+HbxbGi+yd2x88Gjn9dGr7FZK34RUDooH60BCX9P8N9X\n        T+n10MzzX7ZQOsLfe8FKc1/X8AybI5SYm1GMyfKD4QBt6JG4HKAjPHzBzcIpfN3d\n        7BM11Imkrz7LcbUG+F23NVsi6n5IIGT1WqwCRIH2PpECgYEA/SJ5Ra4d0hUS5RYB\n        zABquM3sp7JsKxCn7O5PqNLB4TgH9dXtWFhaFVB6juMGyHbvktVH0j4lps/Te0rk\n        VU2zU1XxvCTFhtcCYUtNk0cRw6LH8feKiorXHdDRB33t0c47QSD/6AGOjBtxqD7B\n        3ZxyR3P+7RdQopLLRFN+FHAnmzsCgYEA9VSGZDFSK+fbg4CgwkWdzuHrAXaUEv0U\n        ovqqWd/yXB9wauEvRHnOrSgW6hFZQiatJOXx0KnalJQzohz/SLGO0MqGtwQbYWVT\n        WiJgjUbNeiPEHBeUA6U55lVQr26kQSUWdXEtRbDz+hqV1K+6tTEMzaSPmJiHNgki\n        lNMO2gqGQd0CgYBJ268qx5zn2UJEGWG41j5NYbg1TfgFsLxugzI2/heX0TNxZVP1\n        PQI7ydmYq2ElSJ6qZxSnoX5255i7FqT8xskV/bOkw83mhAGrxb8Cw+/I90wDq8h+\n        l/ggOPdkijfDybq8TBae6SVgd/l3r6f9M1KcypmNMApVBSPN8daNvBOyVQKBgQDo\n        sj2utyFrx8Xsm4rf+kxOuPbBMooM4MQ8OmpuSP6G5sMofWLqHmcs0sO5TK9PEYRV\n        ZU3ST+ml2FSJRdvWRaRi4laZLWoTHZrL+aN/HVM0sMwIoUyhkIy0ruOTIuzlZZpB\n        1xHL8qXX6nOHgw8jYdz1CUuyv6owVMXaR77kjer+eQKBgByYZlR/eNTzlot0SdFl\n        IbgQ9bV7VLIo+vKzOXE3trfzRJMgUosLTp+5wdSVSW/VBdYZ7Ir3n0bbpY/dGinI\n        VShxPbChhCZnhvG2lEEiekI44m5jHSA6hhtRdt/CrhL65Rw2SE5lMEe8htg1UGus\n        wzLHWHBl72FjbjdhvEgrq60W\n        -----END PRIVATE KEY-----\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "certificatePem": {
                    "type": "string",
                    "description": "chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).\n"
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of this TLS certificate. optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).\n"
                },
                "subjectAlternativeNames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/TlsCertificateSubjectAlternativeName:TlsCertificateSubjectAlternativeName"
                    },
                    "description": "subject alternative names (SANs) from the leaf of this TLS certificate\n"
                }
            },
            "required": [
                "certificatePem",
                "privateKeyPem",
                "subjectAlternativeNames"
            ],
            "inputProperties": {
                "certificatePem": {
                    "type": "string",
                    "description": "chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "human-readable description of this TLS certificate. optional, max 255 bytes.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.\n"
                },
                "privateKeyPem": {
                    "type": "string",
                    "description": "private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).\n",
                    "willReplaceOnChanges": true
                },
                "subjectAlternativeNames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ngrok:index/TlsCertificateSubjectAlternativeName:TlsCertificateSubjectAlternativeName"
                    },
                    "description": "subject alternative names (SANs) from the leaf of this TLS certificate\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "certificatePem",
                "privateKeyPem"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TlsCertificate resources.\n",
                "properties": {
                    "certificatePem": {
                        "type": "string",
                        "description": "chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "human-readable description of this TLS certificate. optional, max 255 bytes.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.\n"
                    },
                    "privateKeyPem": {
                        "type": "string",
                        "description": "private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).\n",
                        "willReplaceOnChanges": true
                    },
                    "subjectAlternativeNames": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ngrok:index/TlsCertificateSubjectAlternativeName:TlsCertificateSubjectAlternativeName"
                        },
                        "description": "subject alternative names (SANs) from the leaf of this TLS certificate\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    }
}